<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Customer Love Quote Cards</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --card-col-min: 380px;
            /* JS will override based on selected format width */
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #1d1d1f;
            overflow-x: hidden;
            position: relative;
        }

        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image:
                radial-gradient(circle at 20% 50%, rgba(255, 255, 255, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 80% 80%, rgba(255, 255, 255, 0.1) 0%, transparent 50%);
            pointer-events: none;
            z-index: 0;
        }

        .container {
            display: flex;
            min-height: 100vh;
            position: relative;
            z-index: 1;
        }

        .panel {
            padding: 32px;
        }

        .left-panel {
            width: 380px;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-right: 1px solid rgba(255, 255, 255, 0.3);
            display: flex;
            flex-direction: column;
            gap: 24px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        }

        .right-panel {
            flex: 1;
            overflow-y: auto;
        }

        h1 {
            font-size: 24px;
            font-weight: 600;
            margin-bottom: 8px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .form-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        label {
            font-size: 13px;
            font-weight: 500;
            color: #6e6e73;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        textarea {
            width: 100%;
            padding: 12px;
            border: 1px solid #d2d2d7;
            border-radius: 8px;
            font-size: 15px;
            font-family: inherit;
            resize: vertical;
            min-height: 120px;
            background: white;
        }

        input[type="text"],
        select {
            width: 100%;
            padding: 12px;
            border: 1px solid #d2d2d7;
            border-radius: 8px;
            font-size: 15px;
            font-family: inherit;
            background: white;
        }

        textarea:focus,
        input:focus,
        select:focus {
            outline: none;
            border-color: #667eea;
        }

        .generate-btn {
            width: 100%;
            padding: 16px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }

        .generate-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.5);
        }

        .generate-btn:active {
            transform: translateY(0);
        }

        .info {
            font-size: 13px;
            color: rgba(255, 255, 255, 0.9);
            margin-bottom: 16px;
            font-weight: 500;
        }

        /* IMPORTANT: auto-fit grid, column count adapts (3 -> 2 -> 1) based on card width */
        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(var(--card-col-min), 1fr));
            gap: 24px;
            max-width: 1400px;
        }

        .card-wrapper {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .card-container {
            background: white;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
            transition: transform 0.2s;
        }

        .card-container:hover {
            transform: translateY(-4px);
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.2);
        }

        .card-container canvas {
            width: 100%;
            height: auto;
            display: block;
        }

        .card-actions {
            display: flex;
            gap: 8px;
        }

        .card-btn {
            flex: 1;
            padding: 10px;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            color: #1d1d1f;
        }

        .card-btn:hover {
            background: white;
            border-color: #667eea;
            transform: translateY(-2px);
        }

        .card-btn:active {
            transform: translateY(0);
        }

        .toast {
            position: fixed;
            bottom: 32px;
            left: 50%;
            transform: translateX(-50%) translateY(100px);
            background: rgba(29, 29, 31, 0.95);
            backdrop-filter: blur(10px);
            color: white;
            padding: 14px 24px;
            border-radius: 24px;
            font-size: 14px;
            font-weight: 500;
            opacity: 0;
            transition: all 0.3s ease;
            z-index: 1000;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.3);
        }

        .toast.show {
            opacity: 1;
            transform: translateX(-50%) translateY(0);
        }
    </style>
</head>

<body>
    <div class="container">
        <div class="panel left-panel">
            <div>
                <h1>Quote Card Generator</h1>
            </div>

            <div class="form-group">
                <label>Quote Text</label>
                <textarea id="quoteText"
                    placeholder="Enter your customer testimonial...">This product changed my life! The attention to detail and customer service is unmatched.</textarea>
            </div>

            <div class="form-group">
                <label>Author (Optional)</label>
                <input type="text" id="authorText" placeholder="Customer name" value="Sarah Johnson" />
            </div>

            <div class="form-group">
                <label>Format</label>
                <select id="formatSelect">
                    <option value="square">Square (1080×1080)</option>
                    <option value="portrait">Portrait (1080×1350)</option>
                    <option value="landscape">Landscape (1600×900)</option>
                </select>
            </div>

            <div class="form-group">
                <label>Corner Radius</label>
                <select id="radiusSelect">
                    <option value="18">18px</option>
                    <option value="26" selected>26px</option>
                    <option value="34">34px</option>
                </select>
            </div>

            <button class="generate-btn" id="generateBtn">Generate</button>
        </div>

        <div class="panel right-panel">
            <div class="info" id="infoText">Click Generate to create cards</div>
            <div class="grid" id="cardsGrid"></div>
        </div>
    </div>

    <div class="toast" id="toast"></div>

    <script>
        // ✅ Your requested shape: minWidth + minHeight (both minimum)
        const FORMATS = {
            square: { minWidth: 1080, minHeight: 1080 },
            portrait: { minWidth: 1080, minHeight: 1350 },
            landscape: { minWidth: 1600, minHeight: 900 },
        };

        const PALETTES = [
            { bg: '#FFF5F5', text: '#2D3748', accent: '#E53E3E' },
            { bg: '#EBF8FF', text: '#2C5282', accent: '#3182CE' },
            { bg: '#F0FFF4', text: '#22543D', accent: '#38A169' },
            { bg: '#FFFAF0', text: '#744210', accent: '#DD6B20' },
            { bg: '#FAF5FF', text: '#44337A', accent: '#805AD5' },
            { bg: '#FFF5F7', text: '#702459', accent: '#D53F8C' },
            { bg: '#E6FFFA', text: '#234E52', accent: '#319795' },
            { bg: '#FFFFF0', text: '#5F370E', accent: '#D69E2E' },
            { bg: '#F7FAFC', text: '#1A202C', accent: '#4A5568' },
            { bg: '#FED7D7', text: '#742A2A', accent: '#C53030' },
            { bg: '#BEE3F8', text: '#2A4365', accent: '#2B6CB0' },
            { bg: '#C6F6D5', text: '#276749', accent: '#2F855A' }
        ];

        const GRADIENTS = [
            ['#667eea', '#764ba2'],
            ['#f093fb', '#f5576c'],
            ['#4facfe', '#00f2fe'],
            ['#43e97b', '#38f9d7'],
            ['#fa709a', '#fee140'],
            ['#30cfd0', '#330867'],
            ['#a8edea', '#fed6e3'],
            ['#ff9a9e', '#fecfef']
        ];

        const FONTS = [
            { quote: 'Georgia, serif', author: 'Georgia, serif' },
            { quote: '-apple-system, BlinkMacSystemFont, sans-serif', author: '-apple-system, BlinkMacSystemFont, sans-serif' },
            { quote: 'Palatino, serif', author: 'Palatino, serif' },
            { quote: 'Trebuchet MS, sans-serif', author: 'Trebuchet MS, sans-serif' },
            { quote: 'Garamond, serif', author: 'Garamond, serif' },
            { quote: 'Verdana, sans-serif', author: 'Verdana, sans-serif' }
        ];

        const DRAWING_STYLES = [
            'hearts', 'stars', 'sparkles', 'confetti', 'circles',
            'diamonds', 'pluses', 'squiggles', 'dots', 'leaves',
            'bolts', 'moons', 'clouds', 'ribbons', 'triangles',
            'hexagons', 'mixed'
        ];

        const LAYOUTS = [
            'centered', 'left', 'icon-top', 'bordered', 'card-in-card', 'offset',
            'split', 'giant-quote', 'underline', 'footer', 'side-stripe',
            'corner-frame', 'diagonal'
        ];

        function seededRandom(seed) {
            let x = Math.sin(seed++) * 10000;
            return x - Math.floor(x);
        }

        function generateDesign(seed) {
            const palette = PALETTES[Math.floor(seededRandom(seed++) * PALETTES.length)];
            const gradient = GRADIENTS[Math.floor(seededRandom(seed++) * GRADIENTS.length)];
            const font = FONTS[Math.floor(seededRandom(seed++) * FONTS.length)];
            const drawingStyle = DRAWING_STYLES[Math.floor(seededRandom(seed++) * DRAWING_STYLES.length)];
            const layout = LAYOUTS[Math.floor(seededRandom(seed++) * LAYOUTS.length)];

            const bgTypes = [
                'solid', 'gradient', 'texture', 'dark', 'pastel', 'paper', 'glass', 'bold',
                'noise', 'stripes', 'spotlight', 'blobs', 'halftone'
            ];

            const bgType = bgTypes[Math.floor(seededRandom(seed++) * bgTypes.length)];
            return { palette, gradient, font, drawingStyle, layout, bgType, seed };
        }

        function roundedRectPath(ctx, x, y, w, h, r) {
            const radius = Math.max(0, Math.min(r, Math.min(w, h) / 2));
            ctx.beginPath();
            ctx.moveTo(x + radius, y);
            ctx.arcTo(x + w, y, x + w, y + h, radius);
            ctx.arcTo(x + w, y + h, x, y + h, radius);
            ctx.arcTo(x, y + h, x, y, radius);
            ctx.arcTo(x, y, x + w, y, radius);
            ctx.closePath();
        }

        function addGrain(ctx, width, height, amount = 0.06, seed = 1) {
            const img = ctx.getImageData(0, 0, width, height);
            const data = img.data;
            for (let i = 0; i < data.length; i += 4) {
                const n = (seededRandom(seed + i) - 0.5) * 255 * amount;
                data[i] = Math.max(0, Math.min(255, data[i] + n));
                data[i + 1] = Math.max(0, Math.min(255, data[i + 1] + n));
                data[i + 2] = Math.max(0, Math.min(255, data[i + 2] + n));
            }
            ctx.putImageData(img, 0, 0);
        }

        // Keeping decorations OFF (like your current file)
        function drawRandomDrawings(ctx, style, width, height, color, seed) { }

        // Wrap, but ALSO handle super long words
        function wrapTextSmart(ctx, text, maxWidth) {
            const tokens = text.split(/\s+/);
            const lines = [];
            let current = '';

            const pushCurrent = () => {
                if (current) lines.push(current);
                current = '';
            };

            for (const token of tokens) {
                const test = current ? (current + ' ' + token) : token;

                if (ctx.measureText(test).width <= maxWidth) {
                    current = test;
                    continue;
                }

                // If current already has content, push it and retry token on new line
                if (current) {
                    pushCurrent();
                }

                // If the token alone fits, put it as a line
                if (ctx.measureText(token).width <= maxWidth) {
                    current = token;
                    continue;
                }

                // Token is too long: break by characters
                let chunk = '';
                for (const ch of token) {
                    const t = chunk + ch;
                    if (ctx.measureText(t).width <= maxWidth) {
                        chunk = t;
                    } else {
                        if (chunk) lines.push(chunk);
                        chunk = ch;
                    }
                }
                if (chunk) current = chunk;
            }

            pushCurrent();
            return lines;
        }

        // If a single word is too wide, optionally increase WIDTH (but only when needed)
        function computeCanvasSize(quote, author, design, format) {
            const base = FORMATS[format];
            const minWidth = base.minWidth;
            const minHeight = base.minHeight;

            // temp ctx for measure
            const t = document.createElement('canvas');
            t.width = minWidth;
            t.height = 10;
            const ctx = t.getContext('2d');

            const padding = minWidth * 0.1;
            const quoteFontSize = Math.floor(minWidth * 0.05);
            const lineHeight = quoteFontSize * 1.4;

            ctx.font = `${quoteFontSize}px ${design.font.quote}`;

            // Check longest token width (for width expansion)
            const tokens = quote.split(/\s+/).filter(Boolean);
            let longest = 0;
            for (const tok of tokens) {
                longest = Math.max(longest, ctx.measureText(tok).width);
            }

            // maxWidth is content area
            let width = minWidth;

            // If longest word doesn't fit in content area, expand width just enough
            const contentMax = (w) => w - (w * 0.1) * 2;
            const neededWidth = Math.ceil(longest + (padding * 2));

            // safety cap (so images don't become insane)
            const maxWidthCap = 2200;

            if (neededWidth > minWidth) {
                width = Math.min(maxWidthCap, neededWidth);
            }

            // Now compute height based on FINAL width
            const t2 = document.createElement('canvas');
            t2.width = width;
            t2.height = 10;
            const ctx2 = t2.getContext('2d');

            const padding2 = width * 0.1;
            const quoteFontSize2 = Math.floor(width * 0.05);
            const lineHeight2 = quoteFontSize2 * 1.4;

            ctx2.font = `${quoteFontSize2}px ${design.font.quote}`;

            const maxTextWidth = width - padding2 * 2;
            const quoteLines = wrapTextSmart(ctx2, quote, maxTextWidth);

            const authorFontSize = author.trim() ? Math.floor(width * 0.034) : 0;

            const quoteHeight = quoteLines.length * lineHeight2;
            const authorHeight = author.trim() ? (authorFontSize * 1.8) : 0;

            const extra = padding2 * 2.4;
            const neededHeight = Math.ceil(quoteHeight + authorHeight + extra);

            const height = Math.max(minHeight, neededHeight);

            return { width, height, minWidth, minHeight };
        }

        // Grid column sizing: if card width is big, fewer columns automatically
        function setGridColumnMin(formatMinWidth, actualCanvasWidth) {
            // Base this on canvas width, scaled for on-screen display
            // 1080 -> ~380, 1600 -> ~560, etc.
            const w = Math.max(formatMinWidth, actualCanvasWidth);
            const colMin = Math.max(320, Math.round(w * 0.35));
            document.documentElement.style.setProperty('--card-col-min', `${colMin}px`);
        }

        function renderCard(canvas, quote, author, design, format, radius) {
            const size = computeCanvasSize(quote, author, design, format);

            canvas.width = size.width;
            canvas.height = size.height;

            const ctx = canvas.getContext('2d');
            const { palette, gradient, font, drawingStyle, layout, bgType, seed } = design;

            ctx.save();
            roundedRectPath(ctx, 0, 0, size.width, size.height, Number(radius));
            ctx.clip();

            const width = size.width;
            const height = size.height;

            // Backgrounds (same logic as yours)
            if (bgType === 'gradient' || bgType === 'glass') {
                const grd = ctx.createLinearGradient(0, 0, width, height);
                grd.addColorStop(0, gradient[0]);
                grd.addColorStop(1, gradient[1]);
                ctx.fillStyle = grd;
                ctx.fillRect(0, 0, width, height);

                if (bgType === 'glass') {
                    ctx.fillStyle = 'rgba(255,255,255,0.18)';
                    ctx.fillRect(0, 0, width, height);
                }
            } else if (bgType === 'dark') {
                ctx.fillStyle = '#12152a';
                ctx.fillRect(0, 0, width, height);
                ctx.fillStyle = 'rgba(255,255,255,0.05)';
                ctx.fillRect(0, 0, width, height);
            } else if (bgType === 'texture') {
                ctx.fillStyle = palette.bg;
                ctx.fillRect(0, 0, width, height);
                ctx.strokeStyle = 'rgba(0,0,0,0.035)';
                ctx.lineWidth = 1;
                for (let i = 0; i < height; i += 36) {
                    ctx.beginPath();
                    ctx.moveTo(0, i);
                    ctx.lineTo(width, i);
                    ctx.stroke();
                }
            } else if (bgType === 'paper') {
                ctx.fillStyle = '#fefefe';
                ctx.fillRect(0, 0, width, height);
                ctx.fillStyle = 'rgba(120,120,120,0.035)';
                for (let i = 0; i < 70; i++) {
                    const x = seededRandom(seed + i) * width;
                    const y = seededRandom(seed + i + 100) * height;
                    ctx.fillRect(x, y, 2, 2);
                }
            } else if (bgType === 'noise') {
                ctx.fillStyle = palette.bg;
                ctx.fillRect(0, 0, width, height);
                addGrain(ctx, width, height, 0.08, seed);
            } else if (bgType === 'stripes') {
                ctx.fillStyle = palette.bg;
                ctx.fillRect(0, 0, width, height);
                ctx.strokeStyle = 'rgba(0,0,0,0.05)';
                ctx.lineWidth = 14;
                for (let i = -height; i < width + height; i += 60) {
                    ctx.beginPath();
                    ctx.moveTo(i, 0);
                    ctx.lineTo(i + height, height);
                    ctx.stroke();
                }
            } else if (bgType === 'spotlight') {
                ctx.fillStyle = palette.bg;
                ctx.fillRect(0, 0, width, height);
                const radial = ctx.createRadialGradient(width * 0.5, height * 0.45, 10, width * 0.5, height * 0.45, Math.max(width, height) * 0.7);
                radial.addColorStop(0, 'rgba(255,255,255,0.45)');
                radial.addColorStop(1, 'rgba(255,255,255,0)');
                ctx.fillStyle = radial;
                ctx.fillRect(0, 0, width, height);
            } else if (bgType === 'halftone') {
                ctx.fillStyle = palette.bg;
                ctx.fillRect(0, 0, width, height);
                ctx.fillStyle = 'rgba(0,0,0,0.05)';
                const step = 26;
                for (let y = 0; y < height; y += step) {
                    for (let x = 0; x < width; x += step) {
                        const r = 2 + seededRandom(seed + x * 7 + y * 11) * 3;
                        ctx.beginPath();
                        ctx.arc(x, y, r, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            } else if (bgType === 'blobs') {
                ctx.fillStyle = palette.bg;
                ctx.fillRect(0, 0, width, height);
                ctx.globalAlpha = 0.25;
                ctx.fillStyle = palette.accent;
                for (let i = 0; i < 6; i++) {
                    const x = seededRandom(seed + i * 10) * width;
                    const y = seededRandom(seed + i * 10 + 1) * height;
                    const r = 120 + seededRandom(seed + i * 10 + 2) * 240;
                    ctx.beginPath();
                    ctx.arc(x, y, r, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.globalAlpha = 1;
            } else {
                ctx.fillStyle = palette.bg;
                ctx.fillRect(0, 0, width, height);
            }

            // Decorations (off)
            const decorColor = bgType === 'dark' ? '#ffffff' : palette.accent;
            drawRandomDrawings(ctx, drawingStyle, width, height, decorColor, seed);

            // Layout
            const padding = width * 0.1;
            let contentY = height * 0.5;
            let contentX = width * 0.5;
            let maxWidth = width - padding * 2;
            let align = 'center';

            if (layout === 'left') {
                align = 'left';
                contentX = padding;
                contentY = height * 0.46;
            } else if (layout === 'icon-top') {
                contentY = height * 0.56;
                ctx.fillStyle = palette.accent;
                ctx.globalAlpha = 0.25;
                ctx.beginPath();
                ctx.arc(width * 0.5, height * 0.23, 52, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
            } else if (layout === 'bordered') {
                ctx.strokeStyle = palette.accent;
                ctx.lineWidth = 7;
                ctx.strokeRect(padding / 2, padding / 2, width - padding, height - padding);
                maxWidth = width - padding * 3;
            } else if (layout === 'card-in-card') {
                const cardPad = padding * 0.85;
                ctx.fillStyle = 'rgba(255,255,255,0.9)';
                ctx.shadowColor = 'rgba(0,0,0,0.12)';
                ctx.shadowBlur = 30;
                ctx.shadowOffsetY = 12;
                ctx.fillRect(cardPad, cardPad, width - cardPad * 2, height - cardPad * 2);
                ctx.shadowColor = 'transparent';
                maxWidth = width - cardPad * 3;
            } else if (layout === 'offset') {
                contentY = height * 0.42;
            } else if (layout === 'split') {
                ctx.globalAlpha = 0.18;
                ctx.fillStyle = palette.accent;
                if (height >= width) {
                    ctx.fillRect(0, 0, width, height * 0.34);
                    contentY = height * 0.58;
                } else {
                    ctx.fillRect(0, 0, width * 0.32, height);
                    align = 'left';
                    contentX = width * 0.38;
                    maxWidth = width * 0.55;
                }
                ctx.globalAlpha = 1;
            } else if (layout === 'giant-quote') {
                ctx.globalAlpha = 0.14;
                ctx.fillStyle = bgType === 'dark' ? '#fff' : palette.accent;
                ctx.font = `900 ${Math.floor(width * 0.28)}px ${font.quote}`;
                ctx.textAlign = 'left';
                ctx.textBaseline = 'top';
                ctx.fillText('“', padding * 0.6, padding * 0.2);
                ctx.globalAlpha = 1;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                contentY = height * 0.56;
                maxWidth = width - padding * 2;
            } else if (layout === 'underline') {
                ctx.globalAlpha = 0.22;
                ctx.fillStyle = palette.accent;
                ctx.fillRect(padding, height * 0.72, width - padding * 2, 10);
                ctx.globalAlpha = 1;
                contentY = height * 0.5;
            } else if (layout === 'footer') {
                ctx.globalAlpha = 0.2;
                ctx.fillStyle = palette.accent;
                ctx.fillRect(0, height * 0.82, width, height * 0.18);
                ctx.globalAlpha = 1;
                contentY = height * 0.48;
            } else if (layout === 'side-stripe') {
                ctx.globalAlpha = 0.2;
                ctx.fillStyle = palette.accent;
                ctx.fillRect(0, 0, 18, height);
                ctx.globalAlpha = 1;
                align = 'left';
                contentX = padding;
                maxWidth = width - padding * 1.6;
            } else if (layout === 'corner-frame') {
                ctx.strokeStyle = palette.accent;
                ctx.lineWidth = 8;
                const s = padding * 0.9;
                ctx.beginPath();
                ctx.moveTo(padding * 0.6, padding * 0.6 + s);
                ctx.lineTo(padding * 0.6, padding * 0.6);
                ctx.lineTo(padding * 0.6 + s, padding * 0.6);

                ctx.moveTo(width - padding * 0.6 - s, padding * 0.6);
                ctx.lineTo(width - padding * 0.6, padding * 0.6);
                ctx.lineTo(width - padding * 0.6, padding * 0.6 + s);

                ctx.moveTo(padding * 0.6, height - padding * 0.6 - s);
                ctx.lineTo(padding * 0.6, height - padding * 0.6);
                ctx.lineTo(padding * 0.6 + s, height - padding * 0.6);

                ctx.moveTo(width - padding * 0.6 - s, height - padding * 0.6);
                ctx.lineTo(width - padding * 0.6, height - padding * 0.6);
                ctx.lineTo(width - padding * 0.6, height - padding * 0.6 - s);
                ctx.stroke();
                maxWidth = width - padding * 2.4;
            } else if (layout === 'diagonal') {
                ctx.globalAlpha = 0.18;
                ctx.fillStyle = palette.accent;
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(width, 0);
                ctx.lineTo(width, height * 0.45);
                ctx.closePath();
                ctx.fill();
                ctx.globalAlpha = 1;
                contentY = height * 0.58;
            }

            // Text (FULL text always)
            ctx.textAlign = align;
            ctx.textBaseline = 'middle';

            const quoteFontSize = Math.floor(width * 0.05);
            const lineHeight = quoteFontSize * 1.4;

            ctx.font = `${quoteFontSize}px ${font.quote}`;
            ctx.fillStyle = bgType === 'dark' ? '#ffffff' : palette.text;

            const quoteLines = wrapTextSmart(ctx, quote, maxWidth);
            const totalQuoteHeight = quoteLines.length * lineHeight;
            let currentY = contentY - totalQuoteHeight / 2;

            quoteLines.forEach(line => {
                const x = align === 'left' ? contentX : width / 2;
                ctx.fillText(line, x, currentY);
                currentY += lineHeight;
            });

            if (author.trim()) {
                const authorFontSize = Math.floor(width * 0.034);
                currentY += authorFontSize * 0.6;

                ctx.font = `600 ${authorFontSize}px ${font.author}`;
                ctx.fillStyle = bgType === 'dark' ? 'rgba(255,255,255,0.85)' : palette.accent;

                const x = align === 'left' ? contentX : width / 2;
                ctx.fillText(`${author}`, x, currentY);
            }

            ctx.restore();
        }

        function showToast(message) {
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.classList.add('show');
            setTimeout(() => toast.classList.remove('show'), 2500);
        }

        async function copyImage(canvas) {
            try {
                const blob = await new Promise(resolve => canvas.toBlob(resolve, 'image/png'));
                await navigator.clipboard.write([new ClipboardItem({ 'image/png': blob })]);
                showToast('Image copied to clipboard');
            } catch (err) {
                showToast('Clipboard failed. Use HTTPS or localhost.');
            }
        }

        function downloadImage(canvas, index) {
            canvas.toBlob(blob => {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `quote-card-${index + 1}.png`;
                a.click();
                URL.revokeObjectURL(url);
                showToast('Image downloaded');
            }, 'image/png');
        }

        function makeDesigns(count = 6) {
            const baseSeed = Date.now();
            const designs = [];
            const usedHashes = new Set();

            for (let i = 0; i < count; i++) {
                let design;
                let hash;
                let attempts = 0;

                do {
                    const seed = baseSeed + i * 1000 + attempts * 100;
                    design = generateDesign(seed);
                    hash = `${design.bgType}-${design.layout}-${PALETTES.indexOf(design.palette)}`;
                    attempts++;
                } while (usedHashes.has(hash) && attempts < 50);

                usedHashes.add(hash);
                designs.push(design);
            }
            return designs;
        }

        let designsCache = makeDesigns(6);

        function generateCards(useSameDesigns = true) {
            const quote = document.getElementById('quoteText').value;
            const author = document.getElementById('authorText').value;
            const format = document.getElementById('formatSelect').value;
            const radius = document.getElementById('radiusSelect').value;

            if (!quote.trim()) {
                showToast('Please enter a quote');
                return;
            }

            const grid = document.getElementById('cardsGrid');
            grid.innerHTML = '';

            if (!useSameDesigns) designsCache = makeDesigns(6);

            // Set grid responsiveness based on selected format minWidth
            // (also adjusted by actual card width if it grows)
            const baseMinW = FORMATS[format].minWidth;

            // Pre-measure once using first design to know if width expands
            const probeSize = computeCanvasSize(quote, author, designsCache[0], format);
            setGridColumnMin(baseMinW, probeSize.width);

            document.getElementById('infoText').textContent =
                `Cards · min ${FORMATS[format].minWidth}×${FORMATS[format].minHeight} (auto grows if needed)`;

            designsCache.forEach((design, index) => {
                const wrapper = document.createElement('div');
                wrapper.className = 'card-wrapper';

                const container = document.createElement('div');
                container.className = 'card-container';

                const canvas = document.createElement('canvas');
                renderCard(canvas, quote, author, design, format, radius);

                container.appendChild(canvas);
                wrapper.appendChild(container);

                const actions = document.createElement('div');
                actions.className = 'card-actions';

                const copyBtn = document.createElement('button');
                copyBtn.className = 'card-btn';
                copyBtn.textContent = 'Copy image';
                copyBtn.onclick = () => copyImage(canvas);

                const downloadBtn = document.createElement('button');
                downloadBtn.className = 'card-btn';
                downloadBtn.textContent = 'Download';
                downloadBtn.onclick = () => downloadImage(canvas, index);

                actions.appendChild(copyBtn);
                actions.appendChild(downloadBtn);
                wrapper.appendChild(actions);

                grid.appendChild(wrapper);
            });

            showToast('Cards generated');
        }

        // Generate button: fresh new designs
        document.getElementById('generateBtn').addEventListener('click', () => generateCards(false));

        // Auto reflect changes instantly
        document.getElementById('formatSelect').addEventListener('change', () => generateCards(true));
        document.getElementById('radiusSelect').addEventListener('change', () => generateCards(true));
        document.getElementById('quoteText').addEventListener('input', () => generateCards(true));
        document.getElementById('authorText').addEventListener('input', () => generateCards(true));

        // On load
        generateCards(true);
    </script>
</body>

</html>