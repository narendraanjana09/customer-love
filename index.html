<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0" />
    <title>❤️ Praise Cards Generator</title>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --panel-w: 380px;
            --card-min: 320px;
            /* grid min column width */
            --card-max: 520px;
            /* stops the “giant card” problem */
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #FFCDD2 0%, #ffffff 100%);
            color: #1d1d1f;
            overflow-x: hidden;
            position: relative;
        }

        body::before {
            content: '';
            position: fixed;
            inset: 0;
            background-image:
                radial-gradient(circle at 20% 50%, rgba(255, 255, 255, 0.10) 0%, transparent 50%),
                radial-gradient(circle at 80% 80%, rgba(255, 255, 255, 0.10) 0%, transparent 50%);
            pointer-events: none;
            z-index: 0;
        }

        .container {
            display: flex;
            min-height: 100vh;
            position: relative;
            z-index: 1;
        }

        .panel {
            padding: 28px;
        }

        .left-panel {
            width: var(--panel-w);
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-right: 1px solid rgba(255, 255, 255, 0.3);
            display: flex;
            flex-direction: column;
            gap: 18px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.10);
            position: sticky;
            top: 0;
            height: 100vh;
            overflow: auto;
            margin: 2%;
            border-radius: 8dvh;
        }

        .right-panel {
            flex: 1;
            overflow-y: auto;
            padding-bottom: 48px;
        }

        .header {
            display: flex;
            align-items: flex-end;
            justify-content: space-between;
            gap: 12px;
        }

        h1 {
            font-size: 22px;
            font-weight: 700;
            line-height: 1.15;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .form-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        label {
            font-size: 12px;
            font-weight: 700;
            color: #6e6e73;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        textarea,
        input[type="text"],
        select {
            width: 100%;
            padding: 12px;
            border: 1px solid #d2d2d7;
            border-radius: 10px;
            font-size: 14px;
            font-family: inherit;
            background: white;
        }

        textarea {
            resize: vertical;
            min-height: 110px;
        }

        textarea:focus,
        input:focus,
        select:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.15);
        }

        .row {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .row>* {
            flex: 1;
        }

        input[type="range"] {
            width: 100%;
            height: 28px;
            accent-color: #667eea;
        }

        .range-row {
            display: flex;
            gap: 12px;
            align-items: center;
        }

        .range-value {
            width: 56px;
            text-align: right;
            font-size: 12px;
            color: #6e6e73;
            font-weight: 800;
            font-variant-numeric: tabular-nums;
        }

        .toggles {
            display: flex;
            gap: 10px;
            align-items: center;
            padding: 10px 12px;
            border: 1px solid rgba(0, 0, 0, 0.08);
            border-radius: 12px;
            background: rgba(255, 255, 255, 0.7);
        }

        .toggles input {
            width: 18px;
            height: 18px;
        }

        .btn-row {
            display: flex;
            gap: 10px;
        }

        .btn {
            flex: 1;
            padding: 14px 14px;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            font-weight: 800;
            font-size: 14px;
            transition: transform .15s, box-shadow .15s, opacity .15s;
        }

        .btn.primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            box-shadow: 0 6px 18px rgba(102, 126, 234, 0.35);
        }

        .btn.secondary {
            background: rgba(0, 0, 0, 0.06);
            color: #1d1d1f;
            border: 1px solid rgba(0, 0, 0, 0.10);
        }

        .btn:hover {
            transform: translateY(-2px);
        }

        .btn:active {
            transform: translateY(0);
            opacity: 0.92;
        }

        .topbar {
            padding: 18px 28px 0 28px;
            color: rgba(255, 255, 255, 0.92);
            font-size: 13px;
            font-weight: 650;
        }

        .topbar .hint {
            opacity: 0.95;
        }

        /* Better responsive grid: never let cards go “full-width giant” */
        .grid {
            padding: 14px 28px 0 28px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(var(--card-min), 1fr));
            gap: 18px;
            align-items: start;
            max-width: 1500px;
        }

        .grid {
            padding: 14px 28px 0 28px;
            display: flex;
            flex-wrap: wrap;
            gap: 18px;
            align-items: flex-start;
            max-width: 1500px;
        }

        .card-wrapper {
            flex: 0 0 min(100%, var(--preview-w, 420px));
            max-width: min(100%, var(--preview-w, 420px));
        }

        .grid {
            grid-template-columns: repeat(auto-fit, minmax(280px, max-content));
            align-items: start;
        }

        .card-container {
            background: rgba(255, 255, 255, 0.96);
            border-radius: 16px;
            overflow: hidden;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.18);
            border: 1px solid rgba(255, 255, 255, 0.25);
            position: relative;
            user-select: none;
        }

        .card-container canvas {
            width: 100%;
            height: auto;
            display: block;
        }

        .card-actions {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        .card-btn {
            flex: 1;
            padding: 10px 12px;
            background: rgba(255, 255, 255, 0.92);
            border: 1px solid rgba(255, 255, 255, 0.35);
            border-radius: 10px;
            font-size: 12px;
            font-weight: 750;
            cursor: pointer;
            transition: transform .15s, background .15s, border-color .15s;
            color: #1d1d1f;
        }

        .card-btn:hover {
            transform: translateY(-2px);
            background: white;
            border-color: rgba(102, 126, 234, 0.5);
        }

        .card-btn:active {
            transform: translateY(0);
        }

        /* Resizer */
        .resize-handle {
            position: absolute;
            right: 10px;
            bottom: 10px;
            width: 18px;
            height: 18px;
            border-radius: 7px;
            background: rgba(255, 255, 255, 0.85);
            border: 1px solid rgba(0, 0, 0, 0.12);
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.18);
            cursor: se-resize;
            display: grid;
            place-items: center;
        }

        .resize-handle::before {
            content: '';
            width: 10px;
            height: 10px;
            border-right: 2px solid rgba(0, 0, 0, 0.35);
            border-bottom: 2px solid rgba(0, 0, 0, 0.35);
            transform: translate(1px, 1px);
        }

        .size-pill {
            position: absolute;
            left: 12px;
            bottom: 12px;
            padding: 6px 10px;
            border-radius: 999px;
            font-size: 11px;
            font-weight: 800;
            color: rgba(255, 255, 255, 0.92);
            background: rgba(0, 0, 0, 0.45);
            backdrop-filter: blur(8px);
            pointer-events: none;
        }

        .toast {
            position: fixed;
            bottom: 26px;
            left: 50%;
            transform: translateX(-50%) translateY(120px);
            background: rgba(29, 29, 31, 0.92);
            backdrop-filter: blur(10px);
            color: white;
            padding: 12px 18px;
            border-radius: 999px;
            font-size: 13px;
            font-weight: 650;
            opacity: 0;
            transition: transform .25s ease, opacity .25s ease;
            z-index: 1000;
            box-shadow: 0 10px 22px rgba(0, 0, 0, 0.30);
        }

        .toast.show {
            opacity: 1;
            transform: translateX(-50%) translateY(0);
        }

        @media (max-width: 980px) {
            .container {
                flex-direction: column;
            }

            .left-panel {
                width: 100%;
                height: auto;
                position: relative;
                border-right: none;
                border-bottom: 1px solid rgba(255, 255, 255, 0.25);
            }

            .grid {
                padding: 14px 18px 0 18px;
            }

            .topbar {
                padding: 18px 18px 0 18px;
            }
        }
    </style>
</head>

<body>
    <div class="container">
        <div class="panel left-panel">
            <div class="header">
                <div>
                    <h1>❤️ Praise Cards Generator</h1>
                </div>
            </div>

            <div class="form-group">
                <label>Praise Message</label>
                <textarea id="quoteText"
                    placeholder="For me, gratitude is an amazing app. I'm a paper and pen girlie but with Gratitude I don't even feel the difference.... a 9.5 out of 10 for me."></textarea>
            </div>

            <div class="form-group">
                <label>User Name</label>
                <input id="authorText" type="text" placeholder="Faith Anazodo" value="" />
            </div>

            <div class="row">
                <div class="form-group">
                    <label>Format</label>
                    <select id="formatSelect">
                        <option value="square">Square (min 1080×1080)</option>
                        <option value="portrait">Portrait (min 1080×1350)</option>
                        <option value="landscape">Landscape (min 1600×900)</option>
                    </select>
                </div>
                <div class="form-group">
                    <label>Cards</label>
                    <select id="countSelect">
                        <option value="6" selected>6</option>
                        <option value="9">9</option>
                        <option value="12">12</option>
                    </select>
                </div>
            </div>

            <div class="row">
                <div class="form-group">
                    <label>Corner Radius</label>
                    <select id="radiusSelect">
                        <option value="18">18px</option>
                        <option value="26" selected>26px</option>
                        <option value="34">34px</option>
                    </select>
                </div>
                <div class="form-group">
                    <label>Style Pack</label>
                    <select id="stylePack">
                        <option value="balanced" selected>Balanced</option>
                        <option value="bold">Bold</option>
                        <option value="minimal">Minimal</option>
                        <option value="playful">Playful</option>
                    </select>
                </div>
            </div>

            <div class="form-group">
                <label>Praise Messagae Font Size</label>
                <div class="range-row">
                    <input id="quoteSize" type="range" min="70" max="140" value="95" />
                    <div class="range-value" id="quoteSizeVal">95%</div>
                </div>
            </div>

            <div class="form-group">
                <label>User Name Font Size</label>
                <div class="range-row">
                    <input id="authorSize" type="range" min="70" max="140" value="105" />
                    <div class="range-value" id="authorSizeVal">105%</div>
                </div>
            </div>

            <div class="toggles">
                <input id="liveUpdate" type="checkbox" checked />
                <label for="liveUpdate"
                    style="text-transform:none; letter-spacing:0; font-weight:800; color:#1d1d1f;">Live update</label>
            </div>

            <div class="btn-row">
                <button class="btn secondary" id="shuffleBtn">Shuffle styles</button>
                <button class="btn primary" id="generateBtn">Generate</button>
            </div>
        </div>

        <div class="panel right-panel">
            <div class="topbar">
                <div class="hint" id="infoText">Tip: Drag the bottom-right corner of a card to resize export width and
                    height.</div>
            </div>
            <div class="grid" id="cardsGrid"></div>
        </div>
    </div>

    <div class="toast" id="toast"></div>

    <script>
        // Minimums, but per-card export can grow via resize drag
        const PREVIEW_SCALE = 0.28;

        const FORMATS = {
            square: { minWidth: 1080, minHeight: 1080 },
            portrait: { minWidth: 1080, minHeight: 1350 },
            landscape: { minWidth: 1600, minHeight: 900 },
        };

        // richer palettes + accents
        const PALETTES = [
            { bg: '#FFF5F5', text: '#2D3748', accent: '#E53E3E' },
            { bg: '#EBF8FF', text: '#1A365D', accent: '#2B6CB0' },
            { bg: '#F0FFF4', text: '#1C4532', accent: '#2F855A' },
            { bg: '#FFFAF0', text: '#5F370E', accent: '#DD6B20' },
            { bg: '#FAF5FF', text: '#2A1F55', accent: '#6B46C1' },
            { bg: '#FFF5F7', text: '#521B41', accent: '#B83280' },
            { bg: '#E6FFFA', text: '#234E52', accent: '#2C7A7B' },
            { bg: '#F7FAFC', text: '#1A202C', accent: '#4A5568' },
            { bg: '#0B1020', text: '#E6E6EA', accent: '#7C3AED' }, // dark
            { bg: '#0F172A', text: '#E2E8F0', accent: '#38BDF8' }, // dark
            { bg: '#111827', text: '#F9FAFB', accent: '#F59E0B' }, // dark
        ];

        const GRADIENTS = [
            ['#667eea', '#764ba2'],
            ['#4facfe', '#00f2fe'],
            ['#f093fb', '#f5576c'],
            ['#43e97b', '#38f9d7'],
            ['#fa709a', '#fee140'],
            ['#30cfd0', '#330867'],
            ['#a8edea', '#fed6e3'],
            ['#ff9a9e', '#fad0c4'],
            ['#1f2937', '#111827'], // dark
            ['#0ea5e9', '#22c55e'],
        ];

        const FONTS = [
            { quote: 'Georgia, serif', author: 'Georgia, serif' },
            { quote: 'Palatino, serif', author: 'Palatino, serif' },
            { quote: 'Garamond, serif', author: 'Garamond, serif' },
            { quote: '-apple-system, BlinkMacSystemFont, sans-serif', author: '-apple-system, BlinkMacSystemFont, sans-serif' },
            { quote: 'Trebuchet MS, sans-serif', author: 'Trebuchet MS, sans-serif' },
            { quote: 'Verdana, sans-serif', author: 'Verdana, sans-serif' }
        ];

        const STYLE_PACKS = {
            balanced: {
                bgTypes: ['solid', 'gradient', 'paper', 'noise', 'halftone', 'blobs', 'glass', 'stripes'],
                layouts: ['centered', 'left', 'split', 'underline', 'footer', 'corner-frame', 'diagonal']
            },
            bold: {
                bgTypes: ['gradient', 'dark', 'stripes', 'blobs'],
                layouts: ['split', 'diagonal', 'side-stripe', 'corner-frame']
            },
            minimal: {
                bgTypes: ['solid', 'paper'],
                layouts: ['centered', 'left', 'underline', 'footer', 'bordered']
            },
            playful: {
                bgTypes: ['gradient', 'halftone', 'blobs', 'noise', 'paper'],
                layouts: ['icon-top', 'split', 'diagonal', 'underline']
            },
        };

        function seededRandom(seed) {
            let x = Math.sin(seed++) * 10000;
            return x - Math.floor(x);
        }

        function pick(arr, seed) {
            return arr[Math.floor(seededRandom(seed) * arr.length)];
        }

        function generateDesign(seed) {
            const pack = STYLE_PACKS[document.getElementById('stylePack').value] || STYLE_PACKS.balanced;
            const palette = pick(PALETTES, seed++);

            const gradient = pick(GRADIENTS, seed++);
            const font = pick(FONTS, seed++);
            const bgType = pick(pack.bgTypes, seed++);
            const layout = pick(pack.layouts, seed++);

            return { palette, gradient, font, bgType, layout, seed };
        }

        function roundedRectPath(ctx, x, y, w, h, r) {
            const radius = Math.max(0, Math.min(r, Math.min(w, h) / 2));
            ctx.beginPath();
            ctx.moveTo(x + radius, y);
            ctx.arcTo(x + w, y, x + w, y + h, radius);
            ctx.arcTo(x + w, y + h, x, y + h, radius);
            ctx.arcTo(x, y + h, x, y, radius);
            ctx.arcTo(x, y, x + w, y, radius);
            ctx.closePath();
        }

        function addGrain(ctx, width, height, amount = 0.06, seed = 1) {
            const img = ctx.getImageData(0, 0, width, height);
            const data = img.data;
            for (let i = 0; i < data.length; i += 4) {
                const n = (seededRandom(seed + i) - 0.5) * 255 * amount;
                data[i] = Math.max(0, Math.min(255, data[i] + n));
                data[i + 1] = Math.max(0, Math.min(255, data[i + 1] + n));
                data[i + 2] = Math.max(0, Math.min(255, data[i + 2] + n));
            }
            ctx.putImageData(img, 0, 0);
        }

        // Break long words and wrap nicely
        function wrapTextSmart(ctx, text, maxWidth) {
            const tokens = text.split(/\s+/).filter(Boolean);
            const lines = [];
            let current = '';

            const push = () => { if (current) lines.push(current); current = ''; };

            for (const tok of tokens) {
                const test = current ? (current + ' ' + tok) : tok;
                if (ctx.measureText(test).width <= maxWidth) {
                    current = test;
                    continue;
                }
                if (current) push();

                if (ctx.measureText(tok).width <= maxWidth) {
                    current = tok;
                    continue;
                }

                // tok too long: split
                let chunk = '';
                for (const ch of tok) {
                    const t = chunk + ch;
                    if (ctx.measureText(t).width <= maxWidth) {
                        chunk = t;
                    } else {
                        if (chunk) lines.push(chunk);
                        chunk = ch;
                    }
                }
                if (chunk) current = chunk;
            }
            push();
            return lines;
        }

        function showToast(msg) {
            const toast = document.getElementById('toast');
            toast.textContent = msg;
            toast.classList.add('show');
            setTimeout(() => toast.classList.remove('show'), 2300);
        }

        async function copyImage(canvas) {
            try {
                const blob = await new Promise(resolve => canvas.toBlob(resolve, 'image/png'));
                await navigator.clipboard.write([new ClipboardItem({ 'image/png': blob })]);
                showToast('Copied image');
            } catch (e) {
                showToast('Clipboard failed. Use HTTPS or localhost.');
            }
        }

        function downloadImage(canvas, index) {
            canvas.toBlob(blob => {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `quote-card-${index + 1}.png`;
                a.click();
                URL.revokeObjectURL(url);
                showToast('Downloaded');
            }, 'image/png');
        }

        function getQuoteMul() { return Number(document.getElementById('quoteSize').value) / 100; }
        function getAuthorMul() { return Number(document.getElementById('authorSize').value) / 100; }

        function updateRangeLabels() {
            document.getElementById('quoteSizeVal').textContent = `${document.getElementById('quoteSize').value}%`;
            document.getElementById('authorSizeVal').textContent = `${document.getElementById('authorSize').value}%`;
        }

        // More “fun” details: subtle doodles
        function drawDoodles(ctx, width, height, color, seed) {
            ctx.save();
            ctx.globalAlpha = 0.18;
            ctx.strokeStyle = color;
            ctx.fillStyle = color;

            const n = 14 + Math.floor(seededRandom(seed));
            for (let i = 0; i < n; i++) {
                const x = seededRandom(seed + i * 11) * width;
                const y = seededRandom(seed + i * 11 + 1) * height;
                const s = 10 + seededRandom(seed + i * 11 + 2) * 26;

                // keep center cleaner
                const cx = width / 2, cy = height / 2;
                if (Math.hypot(x - cx, y - cy) < Math.min(width, height) * 0.22) continue;

                const t = Math.floor(seededRandom(seed + i * 19) * 3);
                if (t === 0) {
                    // dots cluster
                    for (let k = 0; k < 6; k++) {
                        const dx = (seededRandom(seed + i * 31 + k) - .5) * s * 1.5;
                        const dy = (seededRandom(seed + i * 33 + k) - .5) * s * 1.5;
                        const r = 1.2 + seededRandom(seed + i * 37 + k) * 2.4;
                        ctx.beginPath();
                        ctx.arc(x + dx, y + dy, r, 0, Math.PI * 2);
                        ctx.fill();
                    }
                } else if (t === 1) {
                    // spark
                    ctx.lineWidth = 2.2;
                    ctx.lineCap = 'round';
                    ctx.beginPath();
                    ctx.moveTo(x - s * 0.6, y);
                    ctx.lineTo(x + s * 0.6, y);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(x, y - s * 0.6);
                    ctx.lineTo(x, y + s * 0.6);
                    ctx.stroke();
                } else {
                    // squiggle
                    ctx.lineWidth = 2.2;
                    ctx.lineCap = 'round';
                    ctx.beginPath();
                    const len = s * (1.4 + seededRandom(seed + i * 41) * 1.0);
                    const amp = s * (0.22 + seededRandom(seed + i * 43) * 0.22);
                    for (let t2 = 0; t2 <= 1; t2 += 0.07) {
                        const px = x + (t2 - 0.5) * len;
                        const py = y + Math.sin(t2 * Math.PI * 2 * 2.2) * amp;
                        if (t2 === 0) ctx.moveTo(px, py);
                        else ctx.lineTo(px, py);
                    }
                    ctx.stroke();
                }
            }
            ctx.restore();
        }

        function computeSafeStartY(contentY, blockH, safeTop, safeBottom) {
            let y = contentY - blockH / 2;
            if (y < safeTop) y = safeTop;
            if (y + blockH > safeBottom) y = safeBottom - blockH;
            if (y < safeTop) y = safeTop;
            return y;
        }

        // --- State ---
        let designsCache = [];
        let cardState = []; // per-card export size overrides: {w,h} or nulls

        function makeDesigns(count) {
            const baseSeed = Date.now();
            const designs = [];
            const used = new Set();

            for (let i = 0; i < count; i++) {
                let d, tries = 0, hash = '';
                do {
                    const seed = baseSeed + i * 1000 + tries * 111;
                    d = generateDesign(seed);
                    hash = `${d.bgType}-${d.layout}-${PALETTES.indexOf(d.palette)}-${d.font.quote}`;
                    tries++;
                } while (used.has(hash) && tries < 60);
                used.add(hash);
                designs.push(d);
            }
            return designs;
        }

        function hexToRgb(hex) {
            const h = hex.replace('#', '').trim();
            const full = h.length === 3 ? h.split('').map(c => c + c).join('') : h;
            const n = parseInt(full, 16);
            return { r: (n >> 16) & 255, g: (n >> 8) & 255, b: n & 255 };
        }

        function relLuma({ r, g, b }) {
            // sRGB relative luminance
            const srgb = [r, g, b].map(v => {
                v /= 255;
                return v <= 0.03928 ? v / 12.92 : Math.pow((v + 0.055) / 1.055, 2.4);
            });
            return 0.2126 * srgb[0] + 0.7152 * srgb[1] + 0.0722 * srgb[2];
        }

        function mixRgb(a, b, t) {
            return {
                r: Math.round(a.r + (b.r - a.r) * t),
                g: Math.round(a.g + (b.g - a.g) * t),
                b: Math.round(a.b + (b.b - a.b) * t),
            };
        }

        function sampleAverageRgb(ctx, x, y, w, h) {
            const img = ctx.getImageData(
                Math.max(0, Math.floor(x)),
                Math.max(0, Math.floor(y)),
                Math.max(1, Math.floor(w)),
                Math.max(1, Math.floor(h))
            ).data;

            let r = 0, g = 0, b = 0, c = 0;
            // sample every Nth pixel for speed
            const step = 16;
            for (let i = 0; i < img.length; i += 4 * step) {
                r += img[i]; g += img[i + 1]; b += img[i + 2];
                c++;
            }
            return { r: r / c, g: g / c, b: b / c };
        }

        // Returns best text + author colors for current drawn background
        function chooseTextColors(ctx, width, height, palette) {
            const sx = width * 0.22;
            const sy = height * 0.30;
            const sw = width * 0.56;
            const sh = height * 0.40;

            const avg = sampleAverageRgb(ctx, sx, sy, sw, sh);
            const L = relLuma(avg);

            const isLightBg = L > 0.55;

            // Quote color
            const quoteColor = isLightBg ? '#111827' : '#FFFFFF';

            // Default author color = accent
            let authorColor = palette.accent;

            // --- FIX FOR DARK CARDS ---
            if (!isLightBg) {
                // Dark background: force author to be readable
                // Option A: soft white (recommended)
                authorColor = 'rgba(255,255,255,0.85)';

                // Option B (if you want accent feel instead):
                // const acc = hexToRgb(palette.accent);
                // const mixed = mixRgb(acc, { r: 255, g: 255, b: 255 }, 0.6);
                // authorColor = `rgb(${mixed.r}, ${mixed.g}, ${mixed.b})`;
            } else {
                // Light background: ensure accent has enough contrast
                const acc = hexToRgb(palette.accent);
                const quoteRgb = hexToRgb(quoteColor);

                const accL = relLuma(acc);
                const quoteL = relLuma(quoteRgb);
                const contrast = (Math.max(accL, quoteL) + 0.05) / (Math.min(accL, quoteL) + 0.05);

                if (contrast < 2.2) {
                    const mixed = mixRgb(acc, quoteRgb, 0.55);
                    authorColor = `rgb(${mixed.r}, ${mixed.g}, ${mixed.b})`;
                }
            }

            return { quoteColor, authorColor };
        }

        function renderCard(canvas, quote, author, design, format, radius, sizeOverride) {
            const base = FORMATS[format];

            // export size (minimum + override)
            let width = Math.max(base.minWidth, (sizeOverride?.w ?? base.minWidth));
            let height = Math.max(base.minHeight, (sizeOverride?.h ?? base.minHeight));

            const quoteMul = getQuoteMul();
            const authorMul = getAuthorMul();

            // measure needed height for full text (auto-grow)
            const m = document.createElement('canvas');
            m.width = width; m.height = 10;
            const ctxM = m.getContext('2d');

            const padding = width * 0.10;
            const maxWidth = width - padding * 2;

            const qSize = Math.floor(width * 0.05 * quoteMul);
            const qLine = qSize * 1.38;

            ctxM.font = `${qSize}px ${design.font.quote}`;
            const lines = wrapTextSmart(ctxM, quote, maxWidth);

            const aSize = author.trim() ? Math.floor(width * 0.034 * authorMul) : 0;
            const aGap = author.trim() ? (aSize * 0.6) : 0;
            const blockH = lines.length * qLine + aGap + (author.trim() ? aSize * 1.6 : 0);

            const needed = Math.ceil(blockH + padding * 2.6);
            height = Math.max(height, needed);

            canvas.width = width;
            canvas.height = height;

            const ctx = canvas.getContext('2d');
            const { palette, gradient, font, bgType, layout, seed } = design;

            // clip
            ctx.save();
            roundedRectPath(ctx, 0, 0, width, height, Number(radius));
            ctx.clip();

            // --- Background ---
            const isDark = (bgType === 'dark');
            if (bgType === 'gradient' || bgType === 'glass') {
                const grd = ctx.createLinearGradient(0, 0, width, height);
                grd.addColorStop(0, gradient[0]);
                grd.addColorStop(1, gradient[1]);
                ctx.fillStyle = grd;
                ctx.fillRect(0, 0, width, height);
                if (bgType === 'glass') {
                    ctx.fillStyle = 'rgba(255,255,255,0.16)';
                    ctx.fillRect(0, 0, width, height);
                }
            } else if (bgType === 'dark') {
                ctx.fillStyle = palette.bg;
                ctx.fillRect(0, 0, width, height);
                ctx.fillStyle = 'rgba(255,255,255,0.04)';
                ctx.fillRect(0, 0, width, height);
            } else if (bgType === 'paper') {
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(0, 0, width, height);
                ctx.globalAlpha = 0.06;
                ctx.fillStyle = palette.accent;
                for (let i = 0; i < 90; i++) {
                    const x = seededRandom(seed + i) * width;
                    const y = seededRandom(seed + i + 100) * height;
                    ctx.fillRect(x, y, 2, 2);
                }
                ctx.globalAlpha = 1;
            } else if (bgType === 'noise') {
                ctx.fillStyle = palette.bg;
                ctx.fillRect(0, 0, width, height);
                addGrain(ctx, width, height, 0.08, seed);
            } else if (bgType === 'stripes') {
                ctx.fillStyle = palette.bg;
                ctx.fillRect(0, 0, width, height);
                ctx.strokeStyle = 'rgba(0,0,0,0.05)';
                ctx.lineWidth = 14;
                for (let i = -height; i < width + height; i += 60) {
                    ctx.beginPath();
                    ctx.moveTo(i, 0);
                    ctx.lineTo(i + height, height);
                    ctx.stroke();
                }
            } else if (bgType === 'halftone') {
                ctx.fillStyle = palette.bg;
                ctx.fillRect(0, 0, width, height);
                ctx.fillStyle = 'rgba(0,0,0,0.05)';
                const step = 26;
                for (let y = 0; y < height; y += step) {
                    for (let x = 0; x < width; x += step) {
                        const r = 2 + seededRandom(seed + x * 7 + y * 11) * 3;
                        ctx.beginPath();
                        ctx.arc(x, y, r, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            } else if (bgType === 'blobs') {
                ctx.fillStyle = palette.bg;
                ctx.fillRect(0, 0, width, height);
                ctx.globalAlpha = 0.22;
                ctx.fillStyle = palette.accent;
                for (let i = 0; i < 3; i++) {
                    const x = seededRandom(seed + i * 10) * width;
                    const y = seededRandom(seed + i * 10 + 1) * height;
                    const r = 120 + seededRandom(seed + i * 10 + 2) * 260;
                    ctx.beginPath();
                    ctx.arc(x, y, r, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.globalAlpha = 1;
            } else {
                ctx.fillStyle = palette.bg;
                ctx.fillRect(0, 0, width, height);
            }

            // doodles (except minimal pack)
            const pack = document.getElementById('stylePack').value;
            if (pack !== 'minimal') {
                const doodleColor = isDark ? 'rgba(255,255,255,1)' : palette.accent;
                drawDoodles(ctx, width, height, doodleColor, seed + 999);
            }

            // --- Layout elements ---
            let contentY = height * 0.52;
            let contentX = width * 0.5;
            let align = 'center';
            let innerMax = width - padding * 2;

            // IMPORTANT FIX:
            // if we draw a LIGHT panel on top of a dark background, do not force white text
            let hasLightPanel = false;

            if (layout === 'left') {
                align = 'left';
                contentX = padding;
                contentY = height * 0.46;
            } else if (layout === 'icon-top') {
                contentY = height * 0.56;
                ctx.globalAlpha = 0.25;
                ctx.fillStyle = palette.accent;
                ctx.beginPath();
                ctx.arc(width * 0.5, height * 0.22, 54, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
            } else if (layout === 'bordered') {
                ctx.strokeStyle = palette.accent;
                ctx.lineWidth = 7;
                ctx.strokeRect(padding / 2, padding / 2, width - padding, height - padding);
                innerMax = width - padding * 3;
            } else if (layout === 'split') {
                ctx.globalAlpha = 0.18;
                ctx.fillStyle = palette.accent;
                if (height >= width) {
                    ctx.fillRect(0, 0, width, height * 0.32);
                    contentY = height * 0.58;
                } else {
                    ctx.fillRect(0, 0, width * 0.32, height);
                    align = 'left';
                    contentX = width * 0.38;
                    innerMax = width * 0.55;
                }
                ctx.globalAlpha = 1;
            } else if (layout === 'underline') {
                ctx.globalAlpha = 0.22;
                ctx.fillStyle = palette.accent;
                ctx.fillRect(padding, height * 0.72, width - padding * 2, 10);
                ctx.globalAlpha = 1;
            } else if (layout === 'footer') {
                ctx.globalAlpha = 0.18;
                ctx.fillStyle = palette.accent;
                ctx.fillRect(0, height * 0.82, width, height * 0.18);
                ctx.globalAlpha = 1;
                contentY = height * 0.48;
            } else if (layout === 'corner-frame') {
                ctx.strokeStyle = palette.accent;
                ctx.lineWidth = 8;
                const s = padding * 0.9;
                ctx.beginPath();
                ctx.moveTo(padding * 0.6, padding * 0.6 + s);
                ctx.lineTo(padding * 0.6, padding * 0.6);
                ctx.lineTo(padding * 0.6 + s, padding * 0.6);
                ctx.moveTo(width - padding * 0.6 - s, padding * 0.6);
                ctx.lineTo(width - padding * 0.6, padding * 0.6);
                ctx.lineTo(width - padding * 0.6, padding * 0.6 + s);
                ctx.moveTo(padding * 0.6, height - padding * 0.6 - s);
                ctx.lineTo(padding * 0.6, height - padding * 0.6);
                ctx.lineTo(padding * 0.6 + s, height - padding * 0.6);
                ctx.moveTo(width - padding * 0.6 - s, height - padding * 0.6);
                ctx.lineTo(width - padding * 0.6, height - padding * 0.6);
                ctx.lineTo(width - padding * 0.6, height - padding * 0.6 - s);
                ctx.stroke();
                innerMax = width - padding * 2.4;
            } else if (layout === 'diagonal') {
                ctx.globalAlpha = 0.18;
                ctx.fillStyle = palette.accent;
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(width, 0);
                ctx.lineTo(width, height * 0.45);
                ctx.closePath();
                ctx.fill();
                ctx.globalAlpha = 1;
                contentY = height * 0.58;
            }

            const { quoteColor, authorColor } = chooseTextColors(ctx, width, height, palette);

            // --- Text render ---
            ctx.textAlign = align;
            ctx.textBaseline = 'top';

            ctx.font = `${qSize}px ${font.quote}`;
            ctx.fillStyle = quoteColor;

            const safeTop = padding * 0.9;
            const safeBottom = height - padding * 0.9;

            const textLines = wrapTextSmart(ctx, quote, innerMax);
            const quoteH = textLines.length * qLine;

            const aBlock = author.trim() ? aSize * 1.6 : 0;
            const totalH = quoteH + aGap + aBlock;

            let y = computeSafeStartY(contentY, totalH, safeTop, safeBottom);
            const x = (align === 'left') ? contentX : width / 2;

            for (const line of textLines) {
                ctx.fillText(line, x, y);
                y += qLine;
            }

            if (author.trim()) {
                y += aGap;
                ctx.font = `800 ${aSize}px ${font.author}`;
                ctx.fillStyle = authorColor;
                ctx.fillText(author, x, y);
            }

            ctx.restore();
        }

        function attachResize(handle, canvas, index, wrapperEl) {
            let startX = 0, startY = 0;
            let startW = 0, startH = 0;
            let dragging = false;

            // Convert screen pixels to export pixels based on current displayed scale
            const getScale = () => {
                // wrapper is what controls displayed canvas width
                const displayW = canvas.getBoundingClientRect().width;

                const exportW = canvas.width || 1;
                return exportW / Math.max(1, displayW);
            };

            const onMove = (e) => {
                if (!dragging) return;

                const scale = getScale();

                const dx = (e.clientX - startX) * scale;
                const dy = (e.clientY - startY) * scale;

                const format = document.getElementById('formatSelect').value;
                const base = FORMATS[format];

                // new desired export size from drag
                const newW = Math.max(base.minWidth, Math.round(startW + dx));
                const newH = Math.max(base.minHeight, Math.round(startH + dy));

                cardState[index] = { w: newW, h: newH };

                // re-render only this card for snappy drag
                renderAll({ rerenderOnlyIndex: index });
            };

            const onUp = (e) => {
                if (!dragging) return;
                dragging = false;
                try { handle.releasePointerCapture(e.pointerId); } catch { }
                window.removeEventListener('pointermove', onMove);
                window.removeEventListener('pointerup', onUp);
                document.body.style.cursor = '';
                document.body.style.userSelect = '';
            };

            handle.addEventListener('pointerdown', (e) => {
                e.preventDefault();
                e.stopPropagation();

                dragging = true;
                startX = e.clientX;
                startY = e.clientY;

                // start from current export size
                startW = canvas.width;
                startH = canvas.height;

                // capture pointer so it keeps resizing even if cursor leaves handle
                handle.setPointerCapture(e.pointerId);

                document.body.style.cursor = 'se-resize';
                document.body.style.userSelect = 'none';

                window.addEventListener('pointermove', onMove, { passive: false });
                window.addEventListener('pointerup', onUp, { passive: false });
            });
        }

        function buildCard(index) {
            const wrapper = document.createElement('div');
            wrapper.className = 'card-wrapper';

            const container = document.createElement('div');
            container.className = 'card-container';

            const canvas = document.createElement('canvas');

            const handle = document.createElement('div');
            handle.className = 'resize-handle';
            handle.title = 'Drag to resize export';

            const pill = document.createElement('div');
            pill.className = 'size-pill';
            pill.textContent = '—';

            container.appendChild(canvas);
            container.appendChild(handle);
            container.appendChild(pill);
            wrapper.appendChild(container);

            const actions = document.createElement('div');
            actions.className = 'card-actions';

            const copyBtn = document.createElement('button');
            copyBtn.className = 'card-btn';
            copyBtn.textContent = 'Copy image';
            copyBtn.onclick = () => copyImage(canvas);

            const dlBtn = document.createElement('button');
            dlBtn.className = 'card-btn';
            dlBtn.textContent = 'Download';
            dlBtn.onclick = () => downloadImage(canvas, index);

            actions.appendChild(copyBtn);
            actions.appendChild(dlBtn);
            wrapper.appendChild(actions);

            attachResize(handle, canvas, index, wrapper);


            return { wrapper, canvas, pill };
        }

        function renderAll({ newDesigns = false, rerenderOnlyIndex = null } = {}) {
            const quote = document.getElementById('quoteText').value;
            const author = document.getElementById('authorText').value;
            const format = document.getElementById('formatSelect').value;
            const radius = document.getElementById('radiusSelect').value;
            const count = Number(document.getElementById('countSelect').value);

            if (!quote.trim()) {
                showToast('Please enter a quote');
                return;
            }

            // designs
            if (newDesigns || designsCache.length !== count) {
                designsCache = makeDesigns(count);
                cardState = Array.from({ length: count }, () => ({ w: null, h: null }));
            }

            const info = document.getElementById('infoText');
            info.textContent = `Format min ${FORMATS[format].minWidth}×${FORMATS[format].minHeight}. Drag bottom-right handle to resize export.`;

            // if rerenderOnlyIndex: just redraw that canvas
            if (rerenderOnlyIndex !== null) {
                const item = domCards[rerenderOnlyIndex];
                renderCard(item.canvas, quote, author, designsCache[rerenderOnlyIndex], format, radius, cardState[rerenderOnlyIndex]);

                item.pill.textContent = `${item.canvas.width}×${item.canvas.height}`;

                const previewW = Math.round(item.canvas.width * PREVIEW_SCALE);
                const capped = Math.min(previewW, 700);
                item.wrapper.style.setProperty('--preview-w', `${capped}px`);
                return;
            }

            // full rebuild
            const grid = document.getElementById('cardsGrid');
            grid.innerHTML = '';
            domCards = [];

            for (let i = 0; i < count; i++) {
                const card = buildCard(i);
                grid.appendChild(card.wrapper);
                domCards.push(card);

                renderCard(card.canvas, quote, author, designsCache[i], format, radius, cardState[i]);
                card.pill.textContent = `${card.canvas.width}×${card.canvas.height}`;


                const previewW = Math.round(card.canvas.width * PREVIEW_SCALE);
                const capped = Math.min(previewW, 700); // cap so UX stays sane
                card.wrapper.style.setProperty('--preview-w', `${capped}px`);
            }

            showToast(newDesigns ? 'Generated new styles' : 'Updated');
        }

        // --- Wire UI ---
        let domCards = [];

        function maybeLiveRender() {
            if (document.getElementById('liveUpdate').checked) {
                renderAll({ newDesigns: false });
            }
        }

        document.getElementById('generateBtn').addEventListener('click', () => renderAll({ newDesigns: true }));
        document.getElementById('shuffleBtn').addEventListener('click', () => renderAll({ newDesigns: true }));

        document.getElementById('formatSelect').addEventListener('change', () => renderAll({ newDesigns: false }));
        document.getElementById('countSelect').addEventListener('change', () => renderAll({ newDesigns: true }));
        document.getElementById('radiusSelect').addEventListener('change', maybeLiveRender);
        document.getElementById('stylePack').addEventListener('change', () => renderAll({ newDesigns: true }));

        document.getElementById('quoteText').addEventListener('input', maybeLiveRender);
        document.getElementById('authorText').addEventListener('input', maybeLiveRender);

        document.getElementById('quoteSize').addEventListener('input', () => {
            updateRangeLabels();
            maybeLiveRender();
        });
        document.getElementById('authorSize').addEventListener('input', () => {
            updateRangeLabels();
            maybeLiveRender();
        });

        // init
        updateRangeLabels();
        const initialCount = Number(document.getElementById('countSelect').value);
        designsCache = makeDesigns(initialCount);
        cardState = Array.from({ length: initialCount }, () => ({ w: null, h: null }));
        renderAll({ newDesigns: false });
    </script>
</body>

</html>