<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Customer Love Quote Cards</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #1d1d1f;
            overflow-x: hidden;
            position: relative;
        }

        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image:
                radial-gradient(circle at 20% 50%, rgba(255, 255, 255, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 80% 80%, rgba(255, 255, 255, 0.1) 0%, transparent 50%);
            pointer-events: none;
            z-index: 0;
        }

        .container {
            display: flex;
            min-height: 100vh;
            position: relative;
            z-index: 1;
        }

        .panel {
            padding: 32px;
        }

        .left-panel {
            width: 380px;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-right: 1px solid rgba(255, 255, 255, 0.3);
            display: flex;
            flex-direction: column;
            gap: 24px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        }

        .right-panel {
            flex: 1;
            overflow-y: auto;
        }

        h1 {
            font-size: 24px;
            font-weight: 600;
            margin-bottom: 8px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .form-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        label {
            font-size: 13px;
            font-weight: 500;
            color: #6e6e73;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        textarea {
            width: 100%;
            padding: 12px;
            border: 1px solid #d2d2d7;
            border-radius: 8px;
            font-size: 15px;
            font-family: inherit;
            resize: vertical;
            min-height: 120px;
            background: white;
        }

        input[type="text"],
        select {
            width: 100%;
            padding: 12px;
            border: 1px solid #d2d2d7;
            border-radius: 8px;
            font-size: 15px;
            font-family: inherit;
            background: white;
        }

        textarea:focus,
        input:focus,
        select:focus {
            outline: none;
            border-color: #667eea;
        }

        .generate-btn {
            width: 100%;
            padding: 16px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }

        .generate-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.5);
        }

        .generate-btn:active {
            transform: translateY(0);
        }

        .info {
            font-size: 13px;
            color: rgba(255, 255, 255, 0.9);
            margin-bottom: 16px;
            font-weight: 500;
        }

        .grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 24px;
            max-width: 1400px;
        }

        .card-wrapper {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .card-container {
            background: white;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
            transition: transform 0.2s;
        }

        .card-container:hover {
            transform: translateY(-4px);
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.2);
        }

        .card-container canvas {
            width: 100%;
            height: auto;
            display: block;
        }

        .card-actions {
            display: flex;
            gap: 8px;
        }

        .card-btn {
            flex: 1;
            padding: 10px;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            color: #1d1d1f;
        }

        .card-btn:hover {
            background: white;
            border-color: #667eea;
            transform: translateY(-2px);
        }

        .card-btn:active {
            transform: translateY(0);
        }

        .toast {
            position: fixed;
            bottom: 32px;
            left: 50%;
            transform: translateX(-50%) translateY(100px);
            background: rgba(29, 29, 31, 0.95);
            backdrop-filter: blur(10px);
            color: white;
            padding: 14px 24px;
            border-radius: 24px;
            font-size: 14px;
            font-weight: 500;
            opacity: 0;
            transition: all 0.3s ease;
            z-index: 1000;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.3);
        }

        .toast.show {
            opacity: 1;
            transform: translateX(-50%) translateY(0);
        }
    </style>
</head>

<body>
    <div class="container">
        <div class="panel left-panel">
            <div>
                <h1>Quote Card Generator</h1>
            </div>

            <div class="form-group">
                <label>Quote Text</label>
                <textarea id="quoteText"
                    placeholder="Enter your customer testimonial...">This product changed my life! The attention to detail and customer service is unmatched.</textarea>
            </div>

            <div class="form-group">
                <label>Author (Optional)</label>
                <input type="text" id="authorText" placeholder="Customer name" value="Sarah Johnson">
            </div>

            <div class="form-group">
                <label>Format</label>
                <select id="formatSelect">
                    <option value="square">Square (1080×1080)</option>
                    <option value="portrait">Portrait (1080×1350)</option>
                    <option value="landscape">Landscape (1600×900)</option>
                </select>
            </div>

            <div class="form-group">
                <label>Corner Radius</label>
                <select id="radiusSelect">
                    <option value="18">18px</option>
                    <option value="26" selected>26px</option>
                    <option value="34">34px</option>
                </select>
            </div>

            <button class="generate-btn" id="generateBtn">Generate</button>
        </div>

        <div class="panel right-panel">
            <div class="info" id="infoText">Click Generate to create 9 unique cards</div>
            <div class="grid" id="cardsGrid"></div>
        </div>
    </div>

    <div class="toast" id="toast"></div>

    <script>
        const FORMATS = {
            square: { width: 1080, height: 1080 },
            portrait: { width: 1080, height: 1350 },
            landscape: { width: 1600, height: 900 },
        };

        const PALETTES = [
            { bg: '#FFF5F5', text: '#2D3748', accent: '#E53E3E' },
            { bg: '#EBF8FF', text: '#2C5282', accent: '#3182CE' },
            { bg: '#F0FFF4', text: '#22543D', accent: '#38A169' },
            { bg: '#FFFAF0', text: '#744210', accent: '#DD6B20' },
            { bg: '#FAF5FF', text: '#44337A', accent: '#805AD5' },
            { bg: '#FFF5F7', text: '#702459', accent: '#D53F8C' },
            { bg: '#E6FFFA', text: '#234E52', accent: '#319795' },
            { bg: '#FFFFF0', text: '#5F370E', accent: '#D69E2E' },
            { bg: '#F7FAFC', text: '#1A202C', accent: '#4A5568' },
            { bg: '#FED7D7', text: '#742A2A', accent: '#C53030' },
            { bg: '#BEE3F8', text: '#2A4365', accent: '#2B6CB0' },
            { bg: '#C6F6D5', text: '#276749', accent: '#2F855A' }
        ];

        const GRADIENTS = [
            ['#667eea', '#764ba2'],
            ['#f093fb', '#f5576c'],
            ['#4facfe', '#00f2fe'],
            ['#43e97b', '#38f9d7'],
            ['#fa709a', '#fee140'],
            ['#30cfd0', '#330867'],
            ['#a8edea', '#fed6e3'],
            ['#ff9a9e', '#fecfef']
        ];

        const FONTS = [
            { quote: 'Georgia, serif', author: 'Georgia, serif' },
            { quote: '-apple-system, BlinkMacSystemFont, sans-serif', author: '-apple-system, BlinkMacSystemFont, sans-serif' },
            { quote: 'Palatino, serif', author: 'Palatino, serif' },
            { quote: 'Trebuchet MS, sans-serif', author: 'Trebuchet MS, sans-serif' },
            { quote: 'Garamond, serif', author: 'Garamond, serif' },
            { quote: 'Verdana, sans-serif', author: 'Verdana, sans-serif' }
        ];

        const DRAWING_STYLES = [
            'hearts', 'stars', 'sparkles', 'confetti', 'circles',
            'diamonds', 'pluses', 'squiggles', 'dots', 'leaves',
            'bolts', 'moons', 'clouds', 'ribbons', 'triangles',
            'hexagons', 'mixed'
        ];

        const LAYOUTS = [
            'centered', 'left', 'icon-top', 'bordered', 'card-in-card', 'offset',
            'split', 'giant-quote', 'underline', 'footer', 'side-stripe',
            'corner-frame', 'diagonal'
        ];


        function seededRandom(seed) {
            let x = Math.sin(seed++) * 10000;
            return x - Math.floor(x);
        }

        function generateDesign(seed) {
            const palette = PALETTES[Math.floor(seededRandom(seed++) * PALETTES.length)];
            const gradient = GRADIENTS[Math.floor(seededRandom(seed++) * GRADIENTS.length)];
            const font = FONTS[Math.floor(seededRandom(seed++) * FONTS.length)];
            const drawingStyle = DRAWING_STYLES[Math.floor(seededRandom(seed++) * DRAWING_STYLES.length)];
            const layout = LAYOUTS[Math.floor(seededRandom(seed++) * LAYOUTS.length)];


            const bgTypes = [
                'solid', 'gradient', 'texture', 'dark', 'pastel', 'paper', 'glass', 'bold',
                'noise', 'stripes', 'spotlight', 'blobs', 'halftone'
            ];

            const bgType = bgTypes[Math.floor(seededRandom(seed++) * bgTypes.length)];

            return { palette, gradient, font, drawingStyle, layout, bgType, seed };
        }

        function wrapText(ctx, text, maxWidth, lineHeight) {
            const words = text.split(' ');
            const lines = [];
            let currentLine = '';

            for (let word of words) {
                const testLine = currentLine + (currentLine ? ' ' : '') + word;
                const metrics = ctx.measureText(testLine);

                if (metrics.width > maxWidth && currentLine) {
                    lines.push(currentLine);
                    currentLine = word;
                } else {
                    currentLine = testLine;
                }
            }

            if (currentLine) {
                lines.push(currentLine);
            }

            return lines;
        }

        function clampLines(lines, maxLines) {
            if (lines.length <= maxLines) return lines;

            const clamped = lines.slice(0, maxLines);
            const lastLine = clamped[maxLines - 1];
            clamped[maxLines - 1] = lastLine.substring(0, lastLine.length - 3) + '...';

            return clamped;
        }

        function drawHandDrawnHeart(ctx, x, y, size, seed) {
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(seededRandom(seed) * 0.3 - 0.15);

            ctx.beginPath();
            ctx.lineWidth = 2.5;
            ctx.strokeStyle = ctx.fillStyle;

            // Hand-drawn wobbly heart
            const wobble = (t) => size * 0.05 * Math.sin(t * 8 + seededRandom(seed + 1) * 10);

            for (let t = 0; t <= Math.PI * 2; t += 0.1) {
                const r = size * (1 + wobble(t));
                let px, py;

                if (t < Math.PI) {
                    px = r * Math.sin(t) * 0.5;
                    py = -r * Math.cos(t) * 0.5;
                } else {
                    const angle = t - Math.PI;
                    px = -r * Math.sin(angle) * 0.5;
                    py = -r * Math.cos(angle) * 0.5;
                }

                py += size * 0.3;

                if (t === 0) ctx.moveTo(px, py);
                else ctx.lineTo(px, py);
            }

            ctx.closePath();
            ctx.globalAlpha = 0.4;
            ctx.fill();
            ctx.globalAlpha = 0.6;
            ctx.stroke();

            ctx.restore();
        }

        function drawHandDrawnStar(ctx, x, y, size, seed) {
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(seededRandom(seed) * Math.PI * 2);

            ctx.beginPath();
            ctx.lineWidth = 2.5;
            ctx.strokeStyle = ctx.fillStyle;

            const points = 5;
            const outerRadius = size;
            const innerRadius = size * 0.4;

            for (let i = 0; i < points * 2; i++) {
                const radius = i % 2 === 0 ? outerRadius : innerRadius;
                const wobble = 1 + seededRandom(seed + i) * 0.1 - 0.05;
                const r = radius * wobble;
                const angle = (Math.PI * i) / points - Math.PI / 2;
                const px = Math.cos(angle) * r;
                const py = Math.sin(angle) * r;

                if (i === 0) ctx.moveTo(px, py);
                else ctx.lineTo(px, py);
            }

            ctx.closePath();
            ctx.globalAlpha = 0.4;
            ctx.fill();
            ctx.globalAlpha = 0.6;
            ctx.stroke();

            ctx.restore();
        }

        function drawHandDrawnSparkle(ctx, x, y, size, seed) {
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(seededRandom(seed) * Math.PI / 4);

            ctx.lineWidth = 3;
            ctx.strokeStyle = ctx.fillStyle;
            ctx.lineCap = 'round';
            ctx.globalAlpha = 0.5;

            // Main cross
            ctx.beginPath();
            ctx.moveTo(-size, 0);
            ctx.lineTo(size, 0);
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(0, -size);
            ctx.lineTo(0, size);
            ctx.stroke();

            // Diagonal lines
            const diag = size * 0.7;
            ctx.beginPath();
            ctx.moveTo(-diag, -diag);
            ctx.lineTo(diag, diag);
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(diag, -diag);
            ctx.lineTo(-diag, diag);
            ctx.stroke();

            ctx.restore();
        }

        function drawHandDrawnCircle(ctx, x, y, size, seed) {
            ctx.save();
            ctx.translate(x, y);

            ctx.beginPath();
            ctx.lineWidth = 2.5;
            ctx.strokeStyle = ctx.fillStyle;

            // Wobbly circle
            for (let angle = 0; angle <= Math.PI * 2; angle += 0.1) {
                const wobble = 1 + Math.sin(angle * 6 + seededRandom(seed) * 10) * 0.08;
                const r = size * wobble;
                const px = Math.cos(angle) * r;
                const py = Math.sin(angle) * r;

                if (angle === 0) ctx.moveTo(px, py);
                else ctx.lineTo(px, py);
            }

            ctx.closePath();
            ctx.globalAlpha = 0.4;
            ctx.fill();
            ctx.globalAlpha = 0.6;
            ctx.stroke();

            ctx.restore();
        }

        function roundedRectPath(ctx, x, y, w, h, r) {
            const radius = Math.max(0, Math.min(r, Math.min(w, h) / 2));
            ctx.beginPath();
            ctx.moveTo(x + radius, y);
            ctx.arcTo(x + w, y, x + w, y + h, radius);
            ctx.arcTo(x + w, y + h, x, y + h, radius);
            ctx.arcTo(x, y + h, x, y, radius);
            ctx.arcTo(x, y, x + w, y, radius);
            ctx.closePath();
        }

        function addGrain(ctx, width, height, amount = 0.06, seed = 1) {
            const img = ctx.getImageData(0, 0, width, height);
            const data = img.data;
            for (let i = 0; i < data.length; i += 4) {
                const n = (seededRandom(seed + i) - 0.5) * 255 * amount;
                data[i] = Math.max(0, Math.min(255, data[i] + n));
                data[i + 1] = Math.max(0, Math.min(255, data[i + 1] + n));
                data[i + 2] = Math.max(0, Math.min(255, data[i + 2] + n));
            }
            ctx.putImageData(img, 0, 0);
        }

        function drawHandDrawnDiamond(ctx, x, y, size, seed) {
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(seededRandom(seed) * 0.6 - 0.3);
            ctx.lineWidth = 2.5;
            ctx.strokeStyle = ctx.fillStyle;
            ctx.globalAlpha = 0.5;

            const wob = (k) => (seededRandom(seed + k) - 0.5) * size * 0.12;

            ctx.beginPath();
            ctx.moveTo(0 + wob(1), -size + wob(2));
            ctx.lineTo(size + wob(3), 0 + wob(4));
            ctx.lineTo(0 + wob(5), size + wob(6));
            ctx.lineTo(-size + wob(7), 0 + wob(8));
            ctx.closePath();
            ctx.fill();
            ctx.globalAlpha = 0.7;
            ctx.stroke();

            ctx.restore();
        }

        function drawHandDrawnPlus(ctx, x, y, size, seed) {
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(seededRandom(seed) * Math.PI / 4);
            ctx.lineWidth = 3;
            ctx.lineCap = 'round';
            ctx.strokeStyle = ctx.fillStyle;
            ctx.globalAlpha = 0.55;

            const wob = (k) => (seededRandom(seed + k) - 0.5) * size * 0.12;

            ctx.beginPath();
            ctx.moveTo(-size + wob(1), 0 + wob(2));
            ctx.lineTo(size + wob(3), 0 + wob(4));
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(0 + wob(5), -size + wob(6));
            ctx.lineTo(0 + wob(7), size + wob(8));
            ctx.stroke();

            ctx.restore();
        }

        function drawHandDrawnSquiggle(ctx, x, y, size, seed) {
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(seededRandom(seed) * 0.5 - 0.25);
            ctx.lineWidth = 3;
            ctx.lineCap = 'round';
            ctx.strokeStyle = ctx.fillStyle;
            ctx.globalAlpha = 0.5;

            const amp = size * (0.25 + seededRandom(seed + 1) * 0.25);
            const len = size * (1.6 + seededRandom(seed + 2) * 1.2);

            ctx.beginPath();
            for (let t = 0; t <= 1; t += 0.05) {
                const px = (t - 0.5) * len;
                const py = Math.sin(t * Math.PI * 2 * (2 + Math.floor(seededRandom(seed + 3) * 2))) * amp;
                if (t === 0) ctx.moveTo(px, py);
                else ctx.lineTo(px, py);
            }
            ctx.stroke();

            ctx.restore();
        }

        function drawHandDrawnDotCluster(ctx, x, y, size, seed) {
            ctx.save();
            ctx.translate(x, y);
            ctx.globalAlpha = 0.45;

            const count = 6 + Math.floor(seededRandom(seed) * 10);
            for (let i = 0; i < count; i++) {
                const dx = (seededRandom(seed + i * 3) - 0.5) * size * 2;
                const dy = (seededRandom(seed + i * 3 + 1) - 0.5) * size * 2;
                const r = (0.12 + seededRandom(seed + i * 3 + 2) * 0.22) * size;
                ctx.beginPath();
                ctx.arc(dx, dy, r, 0, Math.PI * 2);
                ctx.fill();
            }

            ctx.restore();
        }

        function drawHandDrawnLeaf(ctx, x, y, size, seed) {
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(seededRandom(seed) * Math.PI * 2);
            ctx.lineWidth = 2.5;
            ctx.strokeStyle = ctx.fillStyle;
            ctx.globalAlpha = 0.5;

            ctx.beginPath();
            ctx.moveTo(0, -size);
            ctx.quadraticCurveTo(size, -size * 0.2, 0, size);
            ctx.quadraticCurveTo(-size, -size * 0.2, 0, -size);
            ctx.closePath();
            ctx.fill();
            ctx.globalAlpha = 0.7;
            ctx.stroke();

            // vein
            ctx.globalAlpha = 0.35;
            ctx.beginPath();
            ctx.moveTo(0, -size * 0.8);
            ctx.lineTo(0, size * 0.8);
            ctx.stroke();

            ctx.restore();
        }

        function drawHandDrawnBolt(ctx, x, y, size, seed) {
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(seededRandom(seed) * 0.8 - 0.4);
            ctx.lineWidth = 2.5;
            ctx.strokeStyle = ctx.fillStyle;
            ctx.globalAlpha = 0.5;

            const s = size;
            const wob = (k) => (seededRandom(seed + k) - 0.5) * s * 0.12;

            ctx.beginPath();
            ctx.moveTo(-s * 0.2 + wob(1), -s + wob(2));
            ctx.lineTo(s * 0.2 + wob(3), -s * 0.1 + wob(4));
            ctx.lineTo(-s * 0.05 + wob(5), -s * 0.1 + wob(6));
            ctx.lineTo(s * 0.25 + wob(7), s + wob(8));
            ctx.lineTo(-s * 0.25 + wob(9), s * 0.15 + wob(10));
            ctx.lineTo(s * 0.05 + wob(11), s * 0.15 + wob(12));
            ctx.closePath();
            ctx.fill();
            ctx.globalAlpha = 0.7;
            ctx.stroke();

            ctx.restore();
        }

        function drawHandDrawnMoon(ctx, x, y, size, seed) {
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(seededRandom(seed) * 0.5 - 0.25);
            ctx.globalAlpha = 0.5;

            ctx.beginPath();
            ctx.arc(0, 0, size, 0, Math.PI * 2);
            ctx.arc(size * 0.35, -size * 0.1, size * 0.85, 0, Math.PI * 2, true);
            ctx.fill('evenodd');

            ctx.restore();
        }

        function drawHandDrawnCloud(ctx, x, y, size, seed) {
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(seededRandom(seed) * 0.3 - 0.15);
            ctx.globalAlpha = 0.45;

            const r1 = size * 0.55, r2 = size * 0.7, r3 = size * 0.5;
            ctx.beginPath();
            ctx.arc(-size * 0.4, 0, r1, 0, Math.PI * 2);
            ctx.arc(0, -size * 0.25, r2, 0, Math.PI * 2);
            ctx.arc(size * 0.5, 0, r3, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore();
        }

        function drawHandDrawnRibbon(ctx, x, y, size, seed) {
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(seededRandom(seed) * 0.6 - 0.3);
            ctx.globalAlpha = 0.5;

            ctx.beginPath();
            ctx.moveTo(-size, -size * 0.2);
            ctx.quadraticCurveTo(0, -size * 0.8, size, -size * 0.2);
            ctx.quadraticCurveTo(0, size * 0.2, -size, -size * 0.2);
            ctx.closePath();
            ctx.fill();

            ctx.restore();
        }

        function drawHandDrawnTriangle(ctx, x, y, size, seed) {
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(seededRandom(seed) * Math.PI * 2);
            ctx.lineWidth = 2.5;
            ctx.strokeStyle = ctx.fillStyle;
            ctx.globalAlpha = 0.45;

            const wob = (k) => (seededRandom(seed + k) - 0.5) * size * 0.12;

            ctx.beginPath();
            ctx.moveTo(0 + wob(1), -size + wob(2));
            ctx.lineTo(size + wob(3), size + wob(4));
            ctx.lineTo(-size + wob(5), size + wob(6));
            ctx.closePath();
            ctx.fill();
            ctx.globalAlpha = 0.7;
            ctx.stroke();

            ctx.restore();
        }

        function drawHandDrawnHexagon(ctx, x, y, size, seed) {
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(seededRandom(seed) * 0.6 - 0.3);
            ctx.lineWidth = 2.5;
            ctx.strokeStyle = ctx.fillStyle;
            ctx.globalAlpha = 0.45;

            const wob = (k) => (seededRandom(seed + k) - 0.5) * size * 0.10;

            ctx.beginPath();
            for (let i = 0; i < 6; i++) {
                const ang = (Math.PI * 2 * i) / 6 - Math.PI / 2;
                const px = Math.cos(ang) * size + wob(i + 1);
                const py = Math.sin(ang) * size + wob(i + 11);
                if (i === 0) ctx.moveTo(px, py);
                else ctx.lineTo(px, py);
            }
            ctx.closePath();
            ctx.fill();
            ctx.globalAlpha = 0.7;
            ctx.stroke();

            ctx.restore();
        }


        function drawHandDrawnConfetti(ctx, x, y, size, seed) {
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(seededRandom(seed) * Math.PI * 2);

            ctx.fillStyle = ctx.fillStyle;
            ctx.globalAlpha = 0.5;

            // Random small shapes
            const shapeType = Math.floor(seededRandom(seed + 1) * 3);

            if (shapeType === 0) {
                // Rectangle
                ctx.fillRect(-size * 0.5, -size * 0.2, size, size * 0.4);
            } else if (shapeType === 1) {
                // Triangle
                ctx.beginPath();
                ctx.moveTo(0, -size * 0.5);
                ctx.lineTo(size * 0.5, size * 0.5);
                ctx.lineTo(-size * 0.5, size * 0.5);
                ctx.closePath();
                ctx.fill();
            } else {
                // Circle
                ctx.beginPath();
                ctx.arc(0, 0, size * 0.4, 0, Math.PI * 2);
                ctx.fill();
            }

            ctx.restore();
        }

        function drawRandomDrawings(ctx, style, width, height, color, seed) {
            ctx.fillStyle = color;
            ctx.strokeStyle = color;

            const numElements = 8 + Math.floor(seededRandom(seed) * 10);

            const drawOne = (kind, x, y, size, s) => {
                if (kind === 'hearts') return drawHandDrawnHeart(ctx, x, y, size, s);
                if (kind === 'stars') return drawHandDrawnStar(ctx, x, y, size, s);
                if (kind === 'sparkles') return drawHandDrawnSparkle(ctx, x, y, size, s);
                if (kind === 'circles') return drawHandDrawnCircle(ctx, x, y, size * 0.6, s);
                if (kind === 'confetti') return drawHandDrawnConfetti(ctx, x, y, size, s);

                if (kind === 'diamonds') return drawHandDrawnDiamond(ctx, x, y, size * 0.8, s);
                if (kind === 'pluses') return drawHandDrawnPlus(ctx, x, y, size * 0.7, s);
                if (kind === 'squiggles') return drawHandDrawnSquiggle(ctx, x, y, size, s);
                if (kind === 'dots') return drawHandDrawnDotCluster(ctx, x, y, size * 0.6, s);
                if (kind === 'leaves') return drawHandDrawnLeaf(ctx, x, y, size * 0.9, s);
                if (kind === 'bolts') return drawHandDrawnBolt(ctx, x, y, size * 0.9, s);
                if (kind === 'moons') return drawHandDrawnMoon(ctx, x, y, size * 0.7, s);
                if (kind === 'clouds') return drawHandDrawnCloud(ctx, x, y, size * 0.8, s);
                if (kind === 'ribbons') return drawHandDrawnRibbon(ctx, x, y, size * 0.9, s);
                if (kind === 'triangles') return drawHandDrawnTriangle(ctx, x, y, size * 0.8, s);
                if (kind === 'hexagons') return drawHandDrawnHexagon(ctx, x, y, size * 0.75, s);
            };

            for (let i = 0; i < numElements; i++) {
                const x = seededRandom(seed + i * 10) * width;
                const y = seededRandom(seed + i * 10 + 1) * height;
                const size = 14 + seededRandom(seed + i * 10 + 2) * 26;

                // Skip if too close to center
                const centerX = width / 2;
                const centerY = height / 2;
                const distFromCenter = Math.hypot(x - centerX, y - centerY);
                if (distFromCenter < Math.min(width, height) * 0.28) continue;

                let kind = style;
                if (style === 'mixed') {
                    const all = DRAWING_STYLES.filter(s => s !== 'mixed');
                    kind = all[Math.floor(seededRandom(seed + i * 99) * all.length)];
                }

                //drawOne(kind, x, y, size, seed + i * 7);
            }

            ctx.globalAlpha = 1;
        }

        function renderCard(canvas, quote, author, design, format, radius) {
            const { width, height } = FORMATS[format];
            canvas.width = width;
            canvas.height = height;

            const ctx = canvas.getContext('2d');
            const { palette, gradient, font, drawingStyle, layout, bgType, seed } = design;

            // Rounded clip (radius now used)
            ctx.save();
            roundedRectPath(ctx, 0, 0, width, height, Number(radius));
            ctx.clip();

            // Backgrounds
            if (bgType === 'gradient' || bgType === 'glass') {
                const grd = ctx.createLinearGradient(0, 0, width, height);
                grd.addColorStop(0, gradient[0]);
                grd.addColorStop(1, gradient[1]);
                ctx.fillStyle = grd;
                ctx.fillRect(0, 0, width, height);

                if (bgType === 'glass') {
                    ctx.fillStyle = 'rgba(255,255,255,0.18)';
                    ctx.fillRect(0, 0, width, height);
                }
            } else if (bgType === 'dark') {
                ctx.fillStyle = '#12152a';
                ctx.fillRect(0, 0, width, height);
                ctx.fillStyle = 'rgba(255,255,255,0.05)';
                ctx.fillRect(0, 0, width, height);
            } else if (bgType === 'texture') {
                ctx.fillStyle = palette.bg;
                ctx.fillRect(0, 0, width, height);
                ctx.strokeStyle = 'rgba(0,0,0,0.035)';
                ctx.lineWidth = 1;
                for (let i = 0; i < height; i += 36) {
                    ctx.beginPath();
                    ctx.moveTo(0, i);
                    ctx.lineTo(width, i);
                    ctx.stroke();
                }
            } else if (bgType === 'paper') {
                ctx.fillStyle = '#fefefe';
                ctx.fillRect(0, 0, width, height);
                ctx.fillStyle = 'rgba(120,120,120,0.035)';
                for (let i = 0; i < 70; i++) {
                    const x = seededRandom(seed + i) * width;
                    const y = seededRandom(seed + i + 100) * height;
                    ctx.fillRect(x, y, 2, 2);
                }
            } else if (bgType === 'noise') {
                ctx.fillStyle = palette.bg;
                ctx.fillRect(0, 0, width, height);
                addGrain(ctx, width, height, 0.08, seed);
            } else if (bgType === 'stripes') {
                ctx.fillStyle = palette.bg;
                ctx.fillRect(0, 0, width, height);
                ctx.strokeStyle = 'rgba(0,0,0,0.05)';
                ctx.lineWidth = 14;
                for (let i = -height; i < width + height; i += 60) {
                    ctx.beginPath();
                    ctx.moveTo(i, 0);
                    ctx.lineTo(i + height, height);
                    ctx.stroke();
                }
            } else if (bgType === 'spotlight') {
                ctx.fillStyle = palette.bg;
                ctx.fillRect(0, 0, width, height);
                const radial = ctx.createRadialGradient(width * 0.5, height * 0.45, 10, width * 0.5, height * 0.45, Math.max(width, height) * 0.7);
                radial.addColorStop(0, 'rgba(255,255,255,0.45)');
                radial.addColorStop(1, 'rgba(255,255,255,0)');
                ctx.fillStyle = radial;
                ctx.fillRect(0, 0, width, height);
            } else if (bgType === 'halftone') {
                ctx.fillStyle = palette.bg;
                ctx.fillRect(0, 0, width, height);
                ctx.fillStyle = 'rgba(0,0,0,0.05)';
                const step = 26;
                for (let y = 0; y < height; y += step) {
                    for (let x = 0; x < width; x += step) {
                        const r = 2 + seededRandom(seed + x * 7 + y * 11) * 3;
                        ctx.beginPath();
                        ctx.arc(x, y, r, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            } else if (bgType === 'blobs') {
                ctx.fillStyle = palette.bg;
                ctx.fillRect(0, 0, width, height);
                ctx.globalAlpha = 0.25;
                ctx.fillStyle = palette.accent;
                for (let i = 0; i < 6; i++) {
                    const x = seededRandom(seed + i * 10) * width;
                    const y = seededRandom(seed + i * 10 + 1) * height;
                    const r = 120 + seededRandom(seed + i * 10 + 2) * 240;
                    ctx.beginPath();
                    ctx.arc(x, y, r, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.globalAlpha = 1;
            } else {
                ctx.fillStyle = palette.bg;
                ctx.fillRect(0, 0, width, height);
            }

            // Decorations BEFORE layout cards
            const decorColor = bgType === 'dark' ? '#ffffff' : palette.accent;
            drawRandomDrawings(ctx, drawingStyle, width, height, decorColor, seed);

            // Layout primitives
            const padding = width * 0.1;
            let contentY = height * 0.5;
            let contentX = width * 0.5;
            let maxWidth = width - padding * 2;
            let align = 'center';

            // New layouts
            if (layout === 'left') {
                align = 'left';
                contentX = padding;
                contentY = height * 0.46;
            } else if (layout === 'icon-top') {
                contentY = height * 0.56;
                ctx.fillStyle = palette.accent;
                ctx.globalAlpha = 0.25;
                ctx.beginPath();
                ctx.arc(width * 0.5, height * 0.23, 52, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
            } else if (layout === 'bordered') {
                ctx.strokeStyle = palette.accent;
                ctx.lineWidth = 7;
                ctx.strokeRect(padding / 2, padding / 2, width - padding, height - padding);
                maxWidth = width - padding * 3;
            } else if (layout === 'card-in-card') {
                const cardPad = padding * 0.85;
                ctx.fillStyle = 'rgba(255,255,255,0.9)';
                ctx.shadowColor = 'rgba(0,0,0,0.12)';
                ctx.shadowBlur = 30;
                ctx.shadowOffsetY = 12;
                ctx.fillRect(cardPad, cardPad, width - cardPad * 2, height - cardPad * 2);
                ctx.shadowColor = 'transparent';
                maxWidth = width - cardPad * 3;
            } else if (layout === 'offset') {
                contentY = height * 0.42;
            } else if (layout === 'split') {
                // Accent panel on left or top depending on format
                ctx.globalAlpha = 0.18;
                ctx.fillStyle = palette.accent;
                if (height >= width) {
                    ctx.fillRect(0, 0, width, height * 0.34);
                    contentY = height * 0.58;
                } else {
                    ctx.fillRect(0, 0, width * 0.32, height);
                    align = 'left';
                    contentX = width * 0.38;
                    maxWidth = width * 0.55;
                }
                ctx.globalAlpha = 1;
            } else if (layout === 'giant-quote') {
                ctx.globalAlpha = 0.14;
                ctx.fillStyle = bgType === 'dark' ? '#fff' : palette.accent;
                ctx.font = `900 ${Math.floor(height * 0.28)}px ${font.quote}`;
                ctx.textAlign = 'left';
                ctx.textBaseline = 'top';
                ctx.fillText('“', padding * 0.6, padding * 0.2);
                ctx.globalAlpha = 1;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                contentY = height * 0.56;
                maxWidth = width - padding * 2;
            } else if (layout === 'underline') {
                // underline bar near bottom of quote block
                ctx.globalAlpha = 0.22;
                ctx.fillStyle = palette.accent;
                ctx.fillRect(padding, height * 0.72, width - padding * 2, 10);
                ctx.globalAlpha = 1;
                contentY = height * 0.5;
            } else if (layout === 'footer') {
                ctx.globalAlpha = 0.2;
                ctx.fillStyle = palette.accent;
                ctx.fillRect(0, height * 0.82, width, height * 0.18);
                ctx.globalAlpha = 1;
                contentY = height * 0.48;
            } else if (layout === 'side-stripe') {
                ctx.globalAlpha = 0.2;
                ctx.fillStyle = palette.accent;
                ctx.fillRect(0, 0, 18, height);
                ctx.globalAlpha = 1;
                align = 'left';
                contentX = padding;
                maxWidth = width - padding * 1.6;
            } else if (layout === 'corner-frame') {
                ctx.strokeStyle = palette.accent;
                ctx.lineWidth = 8;
                const s = padding * 0.9;
                // 4 corner L shapes
                ctx.beginPath();
                ctx.moveTo(padding * 0.6, padding * 0.6 + s);
                ctx.lineTo(padding * 0.6, padding * 0.6);
                ctx.lineTo(padding * 0.6 + s, padding * 0.6);
                ctx.moveTo(width - padding * 0.6 - s, padding * 0.6);
                ctx.lineTo(width - padding * 0.6, padding * 0.6);
                ctx.lineTo(width - padding * 0.6, padding * 0.6 + s);
                ctx.moveTo(padding * 0.6, height - padding * 0.6 - s);
                ctx.lineTo(padding * 0.6, height - padding * 0.6);
                ctx.lineTo(padding * 0.6 + s, height - padding * 0.6);
                ctx.moveTo(width - padding * 0.6 - s, height - padding * 0.6);
                ctx.lineTo(width - padding * 0.6, height - padding * 0.6);
                ctx.lineTo(width - padding * 0.6, height - padding * 0.6 - s);
                ctx.stroke();
                maxWidth = width - padding * 2.4;
            } else if (layout === 'diagonal') {
                // Diagonal overlay
                ctx.globalAlpha = 0.18;
                ctx.fillStyle = palette.accent;
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(width, 0);
                ctx.lineTo(width, height * 0.45);
                ctx.closePath();
                ctx.fill();
                ctx.globalAlpha = 1;
                contentY = height * 0.58;
            }

            // Text rendering
            ctx.textAlign = align;
            ctx.textBaseline = 'middle';

            const quoteFontSize = Math.floor(height * 0.05);
            ctx.font = `${quoteFontSize}px ${font.quote}`;
            ctx.fillStyle = bgType === 'dark' ? '#ffffff' : palette.text;

            const quoteLines = wrapText(ctx, quote, maxWidth, quoteFontSize * 1.4);
            const clampedQuoteLines = clampLines(quoteLines, 6);

            const totalQuoteHeight = clampedQuoteLines.length * quoteFontSize * 1.4;
            let currentY = contentY - totalQuoteHeight / 2;

            clampedQuoteLines.forEach(line => {
                const x = align === 'left' ? contentX : width / 2;
                ctx.fillText(line, x, currentY);
                currentY += quoteFontSize * 1.4;
            });

            if (author.trim()) {
                const authorFontSize = Math.floor(height * 0.034);
                currentY += authorFontSize * 0.6;

                ctx.font = `600 ${authorFontSize}px ${font.author}`;
                ctx.fillStyle = bgType === 'dark' ? 'rgba(255,255,255,0.85)' : palette.accent;

                const x = align === 'left' ? contentX : width / 2;
                ctx.fillText(`${author}`, x, currentY);
            }

            ctx.restore(); // end clip
        }


        function showToast(message) {
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.classList.add('show');
            setTimeout(() => {
                toast.classList.remove('show');
            }, 2500);
        }

        async function copyImage(canvas) {
            try {
                const blob = await new Promise(resolve => canvas.toBlob(resolve, 'image/png'));
                await navigator.clipboard.write([
                    new ClipboardItem({ 'image/png': blob })
                ]);
                showToast('Image copied to clipboard');
            } catch (err) {
                showToast('Clipboard failed. Use HTTPS or localhost.');
            }
        }

        function downloadImage(canvas, index) {
            canvas.toBlob(blob => {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `quote-card-${index + 1}.png`;
                a.click();
                URL.revokeObjectURL(url);
                showToast('Image downloaded');
            }, 'image/png');
        }

        function generateCards() {
            const quote = document.getElementById('quoteText').value;
            const author = document.getElementById('authorText').value;
            const format = document.getElementById('formatSelect').value;
            const radius = document.getElementById('radiusSelect').value;

            if (!quote.trim()) {
                showToast('Please enter a quote');
                return;
            }

            const grid = document.getElementById('cardsGrid');
            grid.innerHTML = '';

            const { width, height } = FORMATS[format];
            document.getElementById('infoText').textContent = `9 images · ${width}×${height}`;

            const baseSeed = Date.now();
            const designs = [];
            const usedHashes = new Set();

            for (let i = 0; i < 6; i++) {
                let design;
                let hash;
                let attempts = 0;

                do {
                    const seed = baseSeed + i * 1000 + attempts * 100;
                    design = generateDesign(seed);
                    hash = `${design.bgType}-${design.layout}-${PALETTES.indexOf(design.palette)}`;
                    attempts++;
                } while (usedHashes.has(hash) && attempts < 50);

                usedHashes.add(hash);
                designs.push(design);
            }

            designs.forEach((design, index) => {
                const wrapper = document.createElement('div');
                wrapper.className = 'card-wrapper';

                const container = document.createElement('div');
                container.className = 'card-container';

                const canvas = document.createElement('canvas');
                renderCard(canvas, quote, author, design, format, radius);

                container.appendChild(canvas);
                wrapper.appendChild(container);

                const actions = document.createElement('div');
                actions.className = 'card-actions';

                const copyBtn = document.createElement('button');
                copyBtn.className = 'card-btn';
                copyBtn.textContent = 'Copy image';
                copyBtn.onclick = () => copyImage(canvas);

                const downloadBtn = document.createElement('button');
                downloadBtn.className = 'card-btn';
                downloadBtn.textContent = 'Download';
                downloadBtn.onclick = () => downloadImage(canvas, index);

                actions.appendChild(copyBtn);
                actions.appendChild(downloadBtn);
                wrapper.appendChild(actions);

                grid.appendChild(wrapper);
            });

            showToast('9 cards generated');
        }

        document.getElementById('generateBtn').addEventListener('click', generateCards);

        // Generate on load
        generateCards();
    </script>
</body>

</html>